<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World!</title>
    <url>/2023/01/31/Hello%20World!/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>建了个博客，捣鼓了一晚上。结果没想到是主题设置了一晚上。<br>家里网络实在是太慢了啦！！！！Orz<br>这篇文章也拿来试试看。</p>
]]></content>
      <tags>
        <tag>Chat</tag>
      </tags>
  </entry>
  <entry>
    <title>学习一下markdown语法吧</title>
    <url>/2023/02/01/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8Bmarkdown%E8%AF%AD%E6%B3%95%E5%90%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>“#”号测试：<br>#这句话好大<br>##这句话第二大<br>###这句话第三大<br>####这句话第四大<br>#####再大下去就没完了<br>######反正只要在前面加#号就是加粗变大罢<br>#######哇哦7个#号竟然没用了</p>
<hr>
<p>“*”号测试：<br>这是一句前面什么都没有加的文字<br><em>这是一句变成了斜体的文字</em><br><strong>这是一句变成了粗体的文字</strong><br><em><strong>三个星号竟然是粗体+斜体！</strong></em></p>
<hr>
<p>“-“号测试：</p>
<ul>
<li>列表是什么</li>
<li>前面加个-号出现了一个圆点变成了列表<ul>
<li>甚至还有第二级列表<ul>
<li>竟然还有第三级列表<ul>
<li>好像可以无穷无尽</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>数字加点测试：</p>
<ol>
<li>有序列表</li>
<li>他自动帮我换了序号。好帅！<ol>
<li>二级开始了新的排序</li>
</ol>
</li>
</ol>
<hr>
<p>图片测试：<br><img src="/images/favicon.png" alt="大可罢格的Logo"><br><em>大可罢格的Logo</em></p>
<p><img src="http://p1.music.126.net/mvFeIRSFgPrbxchU5BUtAQ==/109951168195571858.jpg" alt="可爱的芙兰老婆抱着小熊玩偶发呆"><br><em>可爱的芙兰老婆抱着小熊玩偶发呆</em></p>
<hr>
<p>加三个”&#96;”号能创建代码块耶</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cout&lt;&lt;&quot;Hello World!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>加”&gt;”竟然能引用一句话！</p>
<blockquote>
<p>叔叔云：“你所热爱的，就是你的生活。”</p>
<blockquote>
<p>蒙古上单云：“祝你身体健康”</p>
</blockquote>
</blockquote>
<hr>
<p>加”|”竟然是表格！？！</p>
<table>
<thead>
<tr>
<th>fl.</th>
<th>jrrp</th>
<th>qd</th>
</tr>
</thead>
<tbody><tr>
<td>星光</td>
<td>114514</td>
<td>520</td>
</tr>
<tr>
<td>芙兰</td>
<td>1919810</td>
<td>520</td>
</tr>
</tbody></table>
<hr>
<p>连续两个回车竟然才是换行</p>
<p>换行了吗</p>
<p>换行了吗</p>
<p>好像换了罢.jpg<br><font color="#0099ff">能换颜色诶！(#0099ff)<br><font color="blue">这个是蓝色(blue)<br><strong><font color="blue">这个是很粗的蓝色(blue)</font></strong></font></font></p>
<font color="black">
为了方便以后写东西，给自己整点颜色看看（划去）

<p><img src="/images/fontcolor.png" alt="大可罢格的Logo"></p>
<hr>
<p>这里能放音乐吗</p>
<!-- 简单示例 (id, server, type)  -->

    <div id="aplayer-FEZdaHLW" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1996926039" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>

<!-- 进阶示例 -->

    <div id="aplayer-QHcUtdUu" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="157288442" data-server="netease" data-type="album" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"></div>
<p>好像失败了……</p>
<hr>
<p>这里能放视频吗！</p>
<iframe src="https://player.bilibili.com/player.html?aid=474503881&page=11&as_wide=1&high_quality=1&danmaku=1" style="width: 62em; height: 35em;" allowfullscreen="allowfullscreen" width="100%" height="100%" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe></font>]]></content>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>番茄炒蛋bot(FLbot)帮助文档v1.00</title>
    <url>/2023/02/04/FLbot-HelpDoc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><font size="6"><strong>目录</strong></font></p>
<ol>
<li><a href="#1">番茄炒蛋bot简介</a></li>
<li><a href="#2">查询类指令</a></li>
<li><a href="#3">功能类指令</a></li>
<li><a href="#4">行动类指令</a></li>
<li><a href="#5">更新日志</a></li>
</ol>
<hr>
<p><a id="1"><font color="black" size="5"><strong>番茄炒蛋bot简介</strong></font></a></p>
<p>欢迎您使用番茄炒蛋bot（FLbot）！该bot是基于go-cqhttp，使用Python语言开发的一款娱乐型群聊机器人，并于2022年11月27日开始开发并投入到个人群聊中使用。欢迎加入个人群719317473一起交流。</p>
<p>部分效果截图：</p>
<p><img src="http://ys-f.ysepan.com/544024507/713425364/mgcvnyr88344H61GQNK2e/FLbot_1.JPG" alt="签到功能"><br><em>签到功能</em></p>
<p><img src="http://ys-f.ysepan.com/544024508/713425366/m76263J22KPLTmgcvny2b/FLbot_3.JPG" alt="五子棋功能"><br><em>五子棋功能</em></p>
<p><img src="http://ys-f.ysepan.com/544024508/713425367/m76263J22KPU2mgcvny57/FLbot_4.JPG" alt="弹奏功能"><br><em>弹奏功能</em></p>
<p><img src="http://ys-f.ysepan.com/544024508/713425368/m76263J22KPU3mgcvny09/FLbot_5.JPG" alt="商店功能"><br><em>商店功能</em></p>
<p><img src="http://ys-f.ysepan.com/544024509/713425370/mgcvnyu55455F36JNT7cd/FLbot_7.JPG" alt="查涩图功能"><br><em>查涩图功能</em></p>
<p>Bot源码：<a href="https://github.com/Star11ght/FLbot">https://github.com/Star11ght/FLbot</a></p>
<p>额外提示：[]符号表示输入限定的内容，实际使用fl时无需额外添加</p>
<hr>
<p><a id="2"><font color="black" size="5"><strong>查询类指令</strong></font></a></p>
<p><font color="black" size="4"><strong>fl.qd</strong></font></p>
<ul>
<li>签到功能，每日刷新，可领积分。</li>
<li>签到积分机制(fl.qdhelp)：<ul>
<li>获得的积分与今日最高人品(jrrp)，好感度(favor)与连续签到天数(ren)有关</li>
<li>随机获得积分x，(8 + jrrp &#x2F; 250) ≤ x ≤ 50</li>
<li>再计算额外奖励率y，favor &#x2F; 10 ≤ y ≤ (ren - 1) &#x2F; 50，若左边界大于右边界则两边界互换</li>
<li>最后得出今日获得的积分为 x(1+y)</li>
<li>若银行账户内有存款，将会支付给您1％ ~ 3％的利息（存款大于10000时为1％ ~ 2％）。</li>
</ul>
</li>
<li>小技巧1：如果身上rp重置卡数量充足且jrrp不高，可使用重置卡提高x的取值再签到</li>
<li>小技巧2：可以在每天签到之前将所有的积分存到银行里获取最多的积分<del>也可以在签到之前玩几百局1A2B猜数字</del></li>
<li>若断签可使用补签卡(fl.use 1)</li>
</ul>
<p><font color="black" size="4"><strong>fl.jrrp</strong></font></p>
<ul>
<li>查询今日人品功能，每日刷新</li>
<li>达到一定值可进入今日人品最高&#x2F;最低排行榜(fl.rank 2&#x2F;fl.rank 4)</li>
<li>可使用rp重置卡提高人品(fl.use 2)，也有可能不变</li>
</ul>
<p><font color="black" size="4"><strong>fl.rank [数字]</strong></font></p>
<ul>
<li>查询各种各样的排名<ul>
<li>fl.rank 1：今日人品排名</li>
<li>fl.rank 2：今日人品历史最高排名</li>
<li>fl.rank 3：现持有积分总排名</li>
<li>fl.rank 4：今日人品历史最低排名</li>
</ul>
</li>
</ul>
<p><font color="black" size="4"><strong>fl.db&#x2F;fl.darkbug</strong></font></p>
<ul>
<li>随机分享MiyakTik的音乐</li>
<li><del>你MiyakTik的音乐和我DarkBug有什么关系</del></li>
</ul>
<p><font color="black" size="4"><strong>fl.me</strong></font></p>
<ul>
<li>可查询自己的个人信息</li>
<li>包含：昵称，好感度，积分，连续签到天数，最高人品</li>
<li><del>favor达到一定值有额外对话</del></li>
</ul>
<p><font color="black" size="4"><strong>fl.help</strong></font></p>
<ul>
<li><del>我觉得你来看这个文档的目的肯定不是来看这一条的</del></li>
</ul>
<hr>
<p><a id="3"><font color="black" size="5"><strong>功能类指令</strong></font></a></p>
<p><font color="black" size="4"><strong>fl.chess [数字(房间号)]</strong></font></p>
<ul>
<li>输入数字即可创建五子棋房间</li>
<li>输入和别人相同的数字即可加入别人的五子棋局</li>
<li>在两个不同群聊间输入同一数字也可跨群对局<del>就是看不到对方下在哪(虚 空 索 敌)</del></li>
<li>棋盘坐标：先字母后数字</li>
</ul>
<p><font color="black" size="4"><strong>fl.tap</strong></font></p>
<ul>
<li>让芙兰戳戳你。真不戳！</li>
</ul>
<p><font color="black" size="4"><strong>fl.game [数字]</strong></font></p>
<ul>
<li>玩各种各样的游戏。目前各种各样&#x3D;2。<ul>
<li>fl.game 1：1A2B猜数字(游戏规则:fl.game 114514)，成功可获得积分</li>
<li>fl.game 2：寻找炸弹人偶，多人游戏胜利可获得积分</li>
</ul>
</li>
</ul>
<p><font color="black" size="4"><strong>fl.piano [音符串]</strong></font></p>
<ul>
<li>让芙兰用钢琴为你弹奏一段旋律。</li>
<li>音符串格式要求（从左到右）：<ul>
<li>（可选）左括号”(“降一个八度，右括号”)”反之，默认为小字一组，最多可使用三个括号</li>
<li>（必选）输入音符0~7，可用合法的升降号#或b，0为空拍无升降号</li>
<li>（可选）加号”+”速度加快一倍，减号”-“速度放慢一倍，默认下为8分音符，范围为全音符~32分音符</li>
<li>如致爱丽丝：fl.piano 33b33b3(721(6-</li>
</ul>
</li>
</ul>
<p><font color="black" size="4"><strong>fl.tune</strong></font></p>
<ul>
<li>与芙兰玩猜音游戏，范围A1~C9，成功可获得5积分</li>
</ul>
<p><font color="black" size="4"><strong>fl.d[骰子面数]</strong></font></p>
<ul>
<li>随机获得n面骰点数(n≥1)</li>
<li><del>实际上是n+1面骰，得出的点数结果中包括0点，扔莫比乌斯环有啥意义吗.jpg</del></li>
</ul>
<p><font color="black" size="4"><strong>fl.pic [数字][图片]</strong></font></p>
<ul>
<li>将图片进行各种各样的翻转。这里的各种各样&#x3D;5。<ul>
<li>fl.pic 1[图片]：水平翻转图片左半边拼在右半边</li>
<li>fl.pic 2[图片]：水平翻转图片右半边拼在左半边</li>
<li>fl.pic 3[图片]：垂直翻转图片上半边拼在下半边</li>
<li>fl.pic 4[图片]：垂直翻转图片下半边拼在上半边</li>
<li>fl.pic 5[图片]：翻转图片颜色</li>
</ul>
</li>
</ul>
<p><font color="black" size="4"><strong>fl.picture [(可选)tag]，[(可选)tag]，……</strong></font></p>
<ul>
<li>查找涩图功能，引用了神代綺凛大佬的API接口，地址：<a href="https://api.lolicon.app/#/setu">https://api.lolicon.app/#/setu</a></li>
<li>不加tag为随机出图，加tag根据tag搜索指定图片，多个tag间用中文逗号隔开</li>
<li><del>保留了R-18功能但是我不说怎么触发还是保群要紧.jpg</del></li>
</ul>
<p><font color="black" size="4"><strong>fl.read [字符串]</strong></font></p>
<ul>
<li>让芙兰用语音复述你发的字符串，简单粗暴</li>
</ul>
<p><font color="black" size="4"><strong>fl.repeat [字符串]</strong></font></p>
<ul>
<li>让芙兰重复你发的字符串，简单粗暴</li>
<li><del>请不要尝试与星光相关的字符串，这改变不了他tljl的事实</del></li>
</ul>
<p><font color="black" size="4"><strong>fl.news</strong></font></p>
<ul>
<li>获取今日的60秒新闻图片，大约每天凌晨两点更新</li>
<li>每天八点整fl也会在群里自动发送图片</li>
</ul>
<p><font color="black" size="4"><strong>fl.head [(可选)QQ号]</strong></font></p>
<ul>
<li>获取该QQ账号的头像</li>
<li>若不输入QQ号则将获取自己的头像</li>
</ul>
<p><font color="black" size="4"><strong>fl.days [YYYY-MM-DD] [事件名称]</strong></font></p>
<ul>
<li>设定倒数日事件，日期格式为四位年份数-两位月份数-两位天数，如2020年1月1日即为2020-01-01</li>
<li>每天凌晨12点芙兰会在主群(719317473)发送所有已设定的倒数日事件的剩余天数</li>
<li>发送fl.days del可删除自己的倒数日事件</li>
</ul>
<p><font color="black" size="4"><strong>fl.ai&#x2F;ai2&#x2F;aitalk [聊天内容]</strong></font></p>
<ul>
<li>与AI聊天机器人对话，ai和ai2为两个不同的机器人</li>
<li>aitalk可让两个机器人互相对话</li>
</ul>
<hr>
<p><a id="4"><font color="black" size="5"><strong>行动类指令</strong></font></a></p>
<p><font color="black" size="4"><strong>fl.name [名字]</strong></font></p>
<ul>
<li>添加自己的称谓，让芙兰以后这么叫你</li>
<li><del>想取名老公就取名老公吧，口亨！我才不会吃醋</del></li>
</ul>
<p><font color="black" size="4"><strong>fl.bank</strong></font></p>
<ul>
<li>使用幻想乡交通银行储蓄功能</li>
<li>有利息，需通过签到获得利息</li>
<li>fl.bank 1 [积分数]：将积分存进银行</li>
<li>fl.bank 2 [积分数]：从银行中取出积分</li>
</ul>
<p><font color="black" size="4"><strong>fl.borrow [QQ号] [积分数]</strong></font></p>
<ul>
<li>将银行卡内的指定积分汇款至别的账号的银行储蓄当中</li>
<li>汇款的账号需至少触发过一次fl.bank功能</li>
</ul>
<p><font color="black" size="4"><strong>fl.favorup</strong></font></p>
<ul>
<li>提升与芙兰的好感度，需花费积分</li>
<li>所需积分(point)与好感度(favor)的关系：point &#x3D; favor × 50</li>
</ul>
<p><font color="black" size="4"><strong>fl.raffle</strong></font></p>
<ul>
<li>花费50积分进行一次抽奖，每天首次抽奖免费，中奖概率50%<ul>
<li>特等奖(1%)：获得500积分</li>
<li>一等奖(4%)：获得200积分</li>
<li>二等奖(10%)：获得100积分</li>
<li>三等奖(15%)：获得50积分</li>
<li>鼓励奖(20%)：获得30积分</li>
</ul>
</li>
</ul>
<p><font color="black" size="4"><strong>fl.store [物品序号]</strong></font></p>
<ul>
<li>前往商店购买物品</li>
<li>输入物品序号即可购买，部分物品需要达到一定好感度才能购买</li>
</ul>
<p><font color="black" size="4"><strong>fl.bag</strong></font></p>
<ul>
<li>查询自己背包内有哪些物品，并标出物品序号</li>
</ul>
<p><font color="black" size="4"><strong>fl.use [物品序号]</strong></font></p>
<ul>
<li>可以使用背包内的物品</li>
<li>使用效果与当前所处位置有关，不同位置可能有不同效果</li>
<li>部分剧情通过使用物品推进</li>
</ul>
<p><font color="black" size="4"><strong>fl.place</strong></font></p>
<ul>
<li>可查询自己当前所处的位置，显示地点序号</li>
</ul>
<p><font color="black" size="4"><strong>fl.move [地点序号]</strong></font></p>
<ul>
<li>前往不同的地点</li>
<li>部分地点每日首次前往会触发随机奖励或事件</li>
<li>部分剧情可通过前往地点推进</li>
</ul>
<hr>
<p><a id="5"><font color="black" size="5"><strong>更新日志</strong></font></a></p>
<p><font color="black" size="4"><strong>Version 1.00 (2023&#x2F;04&#x2F;01)</strong></font></p>
<ul>
<li>将FL迁移至阿里云服务器，修复了众多BUG</li>
<li>增加了fl.days（倒数日功能），修复了fl.read功能</li>
<li>修改了银行功能，存钱取钱需支付1.5%的服务费</li>
<li>优化了主函数代码</li>
</ul>
<p><font color="black" size="4"><strong>Version 0.77 (2023&#x2F;02&#x2F;17)</strong></font></p>
<ul>
<li>增加了news、head、ai功能</li>
<li>增加了凌晨12点倒数日和早上8点60秒新闻的功能</li>
</ul>
<p><font color="black" size="4"><strong>Version 0.66 (2023&#x2F;02&#x2F;06)</strong></font></p>
<ul>
<li>增加了fl.bank功能和fl.borrow功能</li>
<li>修复了积分小数点位数爆炸的bug</li>
<li>修复了jrrp最高记录刷新后无法使用积分相关功能的bug</li>
</ul>
<p><font color="black" size="4"><strong>Version 0.64 (2023&#x2F;02&#x2F;04)</strong></font></p>
<ul>
<li>增加了网页版帮助文档</li>
<li>修改了help功能的输出方式</li>
<li>增加了favorup、raffle、store、bag、use、place和move功能</li>
<li>增加了8个新道具和5(+2)个新地点，共10种move事件和44种use事件</li>
</ul>
<p>（最近一次更新于2023.04.01 21:27）</p>
]]></content>
      <tags>
        <tag>FLbot</tag>
      </tags>
  </entry>
  <entry>
    <title>番茄炒蛋bot(FLbot)道具使用攻略</title>
    <url>/2023/02/07/FLbot-MoveAndUse/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><font color="black" size="4"><strong>关于fl.move和fl.use的使用方法，请参见该文章：</strong></font><br><a href="https://star11ght.github.io/2023/02/04/FLbot-HelpDoc/">https://star11ght.github.io/2023/02/04/FLbot-HelpDoc/</a></p>
<p>关于表格：P为积分，favor为好感度，事件前的括号为触发概率，不带“且”字的不可与前者(或后者)同时触发</p>
<p><font color="black" size="4"><strong>① fl.move</strong></font></p>
<p>特殊事件：移动时有5%的概率会被帝绊倒并失去20P</p>
<table>
<thead>
<tr>
<th>fl.move</th>
<th>当日初次</th>
</tr>
</thead>
<tbody><tr>
<td>0 人间之里</td>
<td>无</td>
</tr>
<tr>
<td>1 雾之湖</td>
<td>(29.99%)+199.99P</td>
</tr>
<tr>
<td>2 红魔馆门口<br>(favor≥15)</td>
<td>无</td>
</tr>
<tr>
<td>2 红魔馆门口<br>(favor&lt;15)</td>
<td>(70%)美铃醒着<br>(30%)美铃睡着</td>
</tr>
<tr>
<td>2-1 红魔馆<br>(地下室)</td>
<td>(60-favor×2%)favor+1<br>(favor×2%)+100P</td>
</tr>
<tr>
<td>2-2 红魔馆<br>(图书馆)</td>
<td>无</td>
</tr>
<tr>
<td>2-3 红魔馆<br>(大堂中央)</td>
<td>无</td>
</tr>
<tr>
<td>2-4 红魔馆<br>(主殿堂)</td>
<td>(25%)favor&lt;20时favor+1，favor≥20时+250P<br>(25%)+50P</td>
</tr>
</tbody></table>
<p><font color="black" size="4"><strong>② fl.use</strong></font></p>
<p>横向为道具序号，纵向为使用地点。<br>序号为1(补签卡)和2(rp重置卡)的物品在任何地点下使用效果均相同。</p>
<p>序号3~5：</p>
<table>
<thead>
<tr>
<th>fl.use</th>
<th>3 ⑨转大肠</th>
<th>4 草莓蛋糕</th>
<th>5 红苹果</th>
</tr>
</thead>
<tbody><tr>
<td>0 人间之里</td>
<td>无</td>
<td>无</td>
<td>(75%)+150P</td>
</tr>
<tr>
<td>1 雾之湖</td>
<td>(50%)+199.99P</td>
<td>(50%)+199.99P</td>
<td>无</td>
</tr>
<tr>
<td>2 红魔馆门口<br>(醒着的美铃)</td>
<td>(favor&lt;15)让美铃睡着</td>
<td>不消耗</td>
<td>不消耗</td>
</tr>
<tr>
<td>2-0 红魔馆门口<br>(睡着的美铃)</td>
<td>让美铃醒来<br>且+250P</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>2-1 红魔馆<br>(地下室)</td>
<td>-100P</td>
<td>+150P</td>
<td>(50-favor×2%)favor+1<br>(favor≥25时10%)+500P</td>
</tr>
<tr>
<td>2-2 红魔馆<br>(图书馆)</td>
<td>其它随机食物</td>
<td>无</td>
<td>不消耗</td>
</tr>
<tr>
<td>2-3 红魔馆<br>(大堂中央)</td>
<td>不消耗<br>且被送回门口</td>
<td>(75%)+123P<br>(25%)被送回门口</td>
<td>+111P</td>
</tr>
<tr>
<td>2-4 红魔馆<br>(主殿堂)</td>
<td>不消耗<br>且被送回门口</td>
<td>(50%)+222P</td>
<td>(40-favor×2%)favor+1<br>(favor≥20时25%)+150P<br>均不符合条件+50P</td>
</tr>
</tbody></table>
<p>序号6~8：</p>
<table>
<thead>
<tr>
<th>fl.use</th>
<th>6 红茶玛奇朵</th>
<th>7 冰糖雪糕</th>
<th>8 黑松露炒饭</th>
</tr>
</thead>
<tbody><tr>
<td>0 人间之里</td>
<td>无</td>
<td>无</td>
<td>+200P</td>
</tr>
<tr>
<td>1 雾之湖</td>
<td>无</td>
<td>+149.99P</td>
<td>+199.99P</td>
</tr>
<tr>
<td>2 红魔馆门口<br>(醒着的美铃)</td>
<td>让美铃睡着</td>
<td>不消耗</td>
<td>不消耗</td>
</tr>
<tr>
<td>2-0 红魔馆门口<br>(睡着的美铃)</td>
<td>无</td>
<td>(40%)+250P</td>
<td>(50%)+300P</td>
</tr>
<tr>
<td>2-1 红魔馆<br>(地下室)</td>
<td>+50P且<br>(30-favor×2%)favor+1<br>(favor≥15时2%)favor+1</td>
<td>无</td>
<td>(60-favor×2%<br>或favor≥30时2%)favor+2<br>(favor×2%<br>或favor≥30时58%)+200P</td>
</tr>
<tr>
<td>2-2 红魔馆<br>(图书馆)</td>
<td>+100P</td>
<td>无</td>
<td>不消耗</td>
</tr>
<tr>
<td>2-3 红魔馆<br>(大堂中央)</td>
<td>(50%)+150P<br>(50%)+50P</td>
<td>不消耗</td>
<td>+220P</td>
</tr>
<tr>
<td>2-4 红魔馆<br>(主殿堂)</td>
<td>不消耗</td>
<td>(50%)+229.99P</td>
<td>不消耗</td>
</tr>
</tbody></table>
<p>序号9~11：</p>
<table>
<thead>
<tr>
<th>fl.use</th>
<th>9 琪露诺冰块</th>
<th>10 冰冻的鱼</th>
<th>11 草莓奶油</th>
</tr>
</thead>
<tbody><tr>
<td>0 人间之里</td>
<td>无</td>
<td>不消耗</td>
<td>无</td>
</tr>
<tr>
<td>1 雾之湖</td>
<td>无</td>
<td>+100P</td>
<td>+220P</td>
</tr>
<tr>
<td>2 红魔馆门口<br>(醒着的美铃)</td>
<td>不消耗</td>
<td>不消耗</td>
<td>不消耗</td>
</tr>
<tr>
<td>2-0 红魔馆门口<br>(睡着的美铃)</td>
<td>无</td>
<td>不消耗</td>
<td>让美铃醒来</td>
</tr>
<tr>
<td>2-1 红魔馆<br>(地下室)</td>
<td>无</td>
<td>不消耗</td>
<td>不消耗</td>
</tr>
<tr>
<td>2-2 红魔馆<br>(图书馆)</td>
<td>不消耗</td>
<td>无</td>
<td>+220P</td>
</tr>
<tr>
<td>2-3 红魔馆<br>(大堂中央)</td>
<td>+100P</td>
<td>(50%)+200P</td>
<td>(30%)+300P<br>(70%)+50P</td>
</tr>
<tr>
<td>2-4 红魔馆<br>(主殿堂)</td>
<td>无</td>
<td>不消耗</td>
<td>不消耗</td>
</tr>
</tbody></table>
<p>序号12~13，23：</p>
<table>
<thead>
<tr>
<th>fl.use</th>
<th>12 苹果草莓派</th>
<th>13 雾之矿泉水</th>
<th>23 木棍</th>
</tr>
</thead>
<tbody><tr>
<td>星光代码没写完……（偷懒中.jpg）</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>序号21：</p>
<table>
<thead>
<tr>
<th>fl.use</th>
<th>21 普通的鱼竿</th>
</tr>
</thead>
<tbody><tr>
<td>0 人间之里</td>
<td>无</td>
</tr>
<tr>
<td>1 雾之湖</td>
<td>(3.63%)rp重置卡<br>(10.91%)烧烤机或+150P<br>(45.4%)随机东方角色</td>
</tr>
<tr>
<td>2 红魔馆门口<br>(醒着的美铃)</td>
<td>无</td>
</tr>
<tr>
<td>2-0 红魔馆门口<br>(睡着的美铃)</td>
<td>无</td>
</tr>
<tr>
<td>2-1 红魔馆<br>(地下室)</td>
<td>无</td>
</tr>
<tr>
<td>2-2 红魔馆<br>(图书馆)</td>
<td>无</td>
</tr>
<tr>
<td>2-3 红魔馆<br>(大堂中央)</td>
<td>被送回门口</td>
</tr>
<tr>
<td>2-4 红魔馆<br>(主殿堂)</td>
<td>无</td>
</tr>
</tbody></table>
<p>序号22（只与使用物品有关，与地点无关）：</p>
<table>
<thead>
<tr>
<th>fl.use</th>
<th>22 烧烤机</th>
</tr>
</thead>
<tbody><tr>
<td>1 补签卡</td>
<td>(50%)变成rp重置卡</td>
</tr>
<tr>
<td>2 rp重置卡</td>
<td>(50%)变成补签卡</td>
</tr>
<tr>
<td>3 ⑨转大肠</td>
<td>不消耗</td>
</tr>
<tr>
<td>4 草莓蛋糕</td>
<td>变成草莓奶油</td>
</tr>
<tr>
<td>5 红苹果</td>
<td>(单独烤)无<br>(包内有草莓奶油)变成苹果草莓派</td>
</tr>
<tr>
<td>6 红茶玛奇朵</td>
<td>不消耗</td>
</tr>
<tr>
<td>7 冰糖雪糕</td>
<td>变成木棍</td>
</tr>
<tr>
<td>8 黑松露炒饭</td>
<td>不消耗</td>
</tr>
<tr>
<td>9 琪露诺冰块</td>
<td>变成雾之矿泉水</td>
</tr>
<tr>
<td>10 冰冻的鱼</td>
<td>+250P</td>
</tr>
<tr>
<td>11 草莓奶油</td>
<td>+50P</td>
</tr>
<tr>
<td>12 苹果草莓派</td>
<td>不消耗</td>
</tr>
<tr>
<td>13 雾之矿泉水</td>
<td>不消耗</td>
</tr>
<tr>
<td>21 普通的鱼竿</td>
<td>无</td>
</tr>
<tr>
<td>22 烧烤机</td>
<td>不消耗</td>
</tr>
<tr>
<td>23 木棍</td>
<td>无</td>
</tr>
</tbody></table>
<p>（最后更新于2023.04.01 22:00）</p>
]]></content>
      <tags>
        <tag>FLbot</tag>
      </tags>
  </entry>
  <entry>
    <title>2023年3月ACM校赛选拔赛复盘+心得</title>
    <url>/2023/03/12/202303ACM/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这次拿了第三，败在了时间上，有些可惜。（封面的123为自己的队伍）<br>一共10道题，A了BCDFH，BF拿下手刹，AJ卡在思路，EGI没动过。<br>接下来按照字母顺序复盘一下。</p>
<p><font size="6"><strong>目录</strong></font></p>
<p><strong><a href="#A">A. Message - From CodeForces 156A</a></strong><br><strong><a href="#B">B. Hometask - From CodeForces 214B</a></strong><br><strong><a href="#C">C. Trees in a Row - From CodeForces 402B</a></strong><br><strong><a href="#D">D. Flag - From CodeForces 16A</a></strong><br><strong><a href="#E">E. Smart Boy - From CodeForces 38F</a></strong><br><strong><a href="#F">F. Airport - From CodeForces 218B</a></strong><br><strong><a href="#G">G. Three Arrays - From CodeForces 392D</a></strong><br><strong><a href="#H">H. Sockets - From CodeForces 257A</a></strong><br><strong><a href="#I">I. Apple Tree - From CodeForces 349D</a></strong><br><strong><a href="#J">J. Game with Strings - From CodeForces 354B</a></strong></p>
<hr>
<p><a id="A"><font color="black" size="5"><strong>A. Message - From CodeForces 156A</strong></font></a></p>
<p>原题地址：<a href="https://codeforces.com/problemset/problem/156/A">https://codeforces.com/problemset/problem/156/A</a></p>
<p><img src="http://ys-f.ysepan.com/544024527/713499178/jhdwlvl88354U71G9PU481/20230309A1.png" alt="A题题面"><br><img src="http://ys-f.ysepan.com/544024527/713499179/jhdwlvl88354U71G9PU5d5/20230309A2.png" alt="A题样例"></p>
<p>题目大意是给两串字符串，求第二串字符串要经过几次变换才能成为第一串字符串的子串，变换方式可以是在末尾删去或增加字符，或者将其中任意一个字符变成其它字符。<br>负责这道题目的是ckt，码完后能对上样例和自己举的一些例子，最后交上去却只有55.5%，并未发现特例。于是在这道题上纠结了半天。<br>比赛结束后去网上搜了一下，找到一个更精简的贪心算法，也是将2串与1串进行1串的长度次比较，找到两个串之间字母能对应上的最大值，次数即为串长-最大值。</p>
<p>本题AC代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">string a,b;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    int len1=a.length();</span><br><span class="line">    int len2=b.length();</span><br><span class="line">    int ans=10000000;</span><br><span class="line">    int len=len2;</span><br><span class="line">    if(len1&lt;len2)//将长度更大的字符串放在前面</span><br><span class="line">    &#123;</span><br><span class="line">        swap(a,b);</span><br><span class="line">        swap(len1,len2);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;len2;i++)//将2串作为基准串，1串与2串进行对比</span><br><span class="line">    &#123;</span><br><span class="line">        int num=0;</span><br><span class="line">        for(int k=i,j=0;k&lt;len2&amp;&amp;j&lt;len1;k++,j++)</span><br><span class="line">        &#123;</span><br><span class="line">           if(b[k]==a[j])</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=min(ans,len-num);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;len1;i++)//将1串作为基准串，2串与1串进行对比</span><br><span class="line">    &#123;</span><br><span class="line">        int num=0;</span><br><span class="line">        for(int k=i,j=0;j&lt;len2&amp;&amp;k&lt;len1;j++,k++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[k]==b[j])</span><br><span class="line">                num++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=min(ans,len-num);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这道题在场的各位竟然都没A出来。估计都紧张了吧（笑）</p>
<hr>
<p><a id="B"><font color="black" size="5"><strong>B. Hometask - From CodeForces 214B</strong></font></a></p>
<p>原题地址：<a href="https://codeforces.com/problemset/problem/214/B">https://codeforces.com/problemset/problem/214/B</a></p>
<p><img src="http://ys-f.ysepan.com/544024538/713499243/o76273W337WNH6lgfsmzee/20230309B1.png" alt="B题题面"><br><img src="http://ys-f.ysepan.com/544024539/713499244/lgfsmzo55465S476UMJ62d/20230309B2.png" alt="B题样例"></p>
<p>AC的第一道题，时间充裕心态良好，拿了个手刹，难度不高。<br>题意是给定n个数字，取出这堆数字中的部分数字或所有数字，并将其拼成能被2，3，5整除的数，求这个数最大是多少。<br>这道题主打的也是个贪心算法。先判断能否被2，3，5整除，思路是拆成10和3，这就意味着凑成这组数需要满足两个条件，即结尾必须是0及所有数的总和能被3整除。若能整除则从大到小一个个输出（输入时用了桶排序计算个数）；若不能，先判断这组数中是否存在“余数+3的整数倍”的数，从小到大查找，若存在除去这个数即可；若不存在“余数+3的整数倍”的数，还可以判断“3-余数+3的整数倍”的数是否大于等于2，除去这两个数即可。若以上都不满足输出-1。</p>
<p>因为是比赛，所以未能简化代码，变量名也瞎取。看个乐就行。</p>
<p>本题AC代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long number[10]=&#123;0&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    long long n,sub=0;</span><br><span class="line">    int x[100005],i;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x[i];</span><br><span class="line">        number[x[i]]++;</span><br><span class="line">        sub = sub + x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    if(number[0]==0)&#123;</span><br><span class="line">        cout&lt;&lt;-1;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(number[0]==n)&#123;</span><br><span class="line">        cout&lt;&lt;0;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int div = sub%3,x1=n,r=0;</span><br><span class="line">    if(div!=0)&#123;</span><br><span class="line">        for(i=0;i&lt;=2;i++)&#123;</span><br><span class="line">            if(number[div+i*3]!=0)break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i==3)&#123;</span><br><span class="line">            if(div==1)&#123;</span><br><span class="line">                for(i=0;i&lt;=2;i++)&#123;</span><br><span class="line">                    while(number[2+i*3]!=0)&#123;</span><br><span class="line">                        r++;</span><br><span class="line">                        number[2+i*3]--;</span><br><span class="line">                        if(r==2)break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(r==2)break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(div==2)&#123;</span><br><span class="line">                for(i=0;i&lt;=2;i++)&#123;</span><br><span class="line">                    while(number[1+i*3]!=0)&#123;</span><br><span class="line">                        r++;</span><br><span class="line">                        number[1+i*3]--;</span><br><span class="line">                        if(r==2)break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(r==2)break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(r!=2)&#123;</span><br><span class="line">                cout&lt;&lt;-1;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            x1=n-2;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            number[div+i*3]--;</span><br><span class="line">            x1=n-1;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    if(number[0]==x1)&#123;</span><br><span class="line">        cout&lt;&lt;0;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=9;i&gt;=0;i--)&#123;</span><br><span class="line">        for(int j=1;j&lt;=number[i];j++)&#123;</span><br><span class="line">            cout&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**************************************************************</span><br><span class="line">    Problem: 3518</span><br><span class="line">    User: 123 [URright]</span><br><span class="line">    Language: C++</span><br><span class="line">    Result: 正确</span><br><span class="line">    Time:13 ms</span><br><span class="line">    Memory:2444 kb</span><br><span class="line">****************************************************************/</span><br></pre></td></tr></table></figure>

<hr>
<p><a id="C"><font color="black" size="5"><strong>C. Trees in a Row - From CodeForces 402B</strong></font></a></p>
<p>原题地址：<a href="https://codeforces.com/problemset/problem/402/B">https://codeforces.com/problemset/problem/402/B</a></p>
<p><img src="http://ys-d.ysepan.com/544024529/713499309/jhdwlvm55465S47JJMMKe1/20230309C1.png" alt="C题题面"><br><img src="http://ys-d.ysepan.com/544024529/713499310/jhdwlvm55465S47JJMMLb7/20230309C2.png" alt="C题样例"></p>
<p>和ckt一起写的代码，他用他的思路我用我的思路写。<br>也是很简单的一题。输入n个数，要求这n个数成等差数列，k为公差，求最少的更改次数，并输出更改过程。<br>思路也很简单，找到符合要求的数最多的一组，然后改剩下不符合的即可。<br>由于不清楚是否要求升序输出，于是多写了一段让其升序输出的代码。</p>
<p>本题AC代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int num[1005],fuhao[1005],in[1005],minuss[1005];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k,maxn=0,left,right,tn=0,tl=0,tr;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;num[i];</span><br><span class="line">        if(i&gt;=2)&#123;</span><br><span class="line">            if(num[i]-num[i-1]==k)&#123;</span><br><span class="line">                if(i-tl+1!=tn)&#123;</span><br><span class="line">                    tl=i-1;</span><br><span class="line">                    tn=2;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    tn++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(tn&gt;maxn)&#123;</span><br><span class="line">                tr=i-1;</span><br><span class="line">                maxn=tn;</span><br><span class="line">                left=tl;</span><br><span class="line">                right=tr;</span><br><span class="line">                tn=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(maxn==0)&#123;</span><br><span class="line">        left=1;</span><br><span class="line">        right=1;</span><br><span class="line">    &#125;</span><br><span class="line">    int minusa,minusb,total=0;</span><br><span class="line">    for(int i=left-1;i&gt;=1;i--)&#123;</span><br><span class="line">        minusa = num[i+1] - k;//yuanbendezhi</span><br><span class="line">        minusb = minusa - num[i];//chazhi</span><br><span class="line">        num[i] = minusa;</span><br><span class="line">        if(minusb &gt; 0)&#123;</span><br><span class="line">            total++;</span><br><span class="line">            fuhao[total] = 1;</span><br><span class="line">            in[total]=i;</span><br><span class="line">            minuss[total]=minusb;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(minusb&lt;0)&#123;</span><br><span class="line">            total++;</span><br><span class="line">            fuhao[total] = -1;</span><br><span class="line">            in[total]=i;</span><br><span class="line">            minuss[total]=-minusb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int red = total;</span><br><span class="line">    for(int i=right+1;i&lt;=n;i++)&#123;</span><br><span class="line">        minusa = num[i-1] + k;//yuanbendezhi</span><br><span class="line">        minusb = minusa - num[i];//chazhi</span><br><span class="line">        num[i] = minusa;</span><br><span class="line">        if(minusb &gt; 0)&#123;</span><br><span class="line">            total++;</span><br><span class="line">            fuhao[total] = 1;</span><br><span class="line">            in[total]=i;</span><br><span class="line">            minuss[total]=minusb;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(minusb&lt;0)&#123;</span><br><span class="line">            total++;</span><br><span class="line">            fuhao[total] = -1;</span><br><span class="line">            in[total]=i;</span><br><span class="line">            minuss[total]=-minusb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;total&lt;&lt;endl;</span><br><span class="line">    for(int i=red;i&gt;=1;i--)&#123;</span><br><span class="line">        if(fuhao[i]==1)cout&lt;&lt;&quot;+ &quot;;</span><br><span class="line">        else cout&lt;&lt;&quot;- &quot;;</span><br><span class="line">        cout&lt;&lt;in[i]&lt;&lt;&quot; &quot;&lt;&lt;minuss[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=red+1;i&lt;=total;i++)&#123;</span><br><span class="line">        if(fuhao[i]==1)cout&lt;&lt;&quot;+ &quot;;</span><br><span class="line">        else cout&lt;&lt;&quot;- &quot;;</span><br><span class="line">        cout&lt;&lt;in[i]&lt;&lt;&quot; &quot;&lt;&lt;minuss[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**************************************************************</span><br><span class="line">    Problem: 2889</span><br><span class="line">    User: 123 [URright]</span><br><span class="line">    Language: C++</span><br><span class="line">    Result: 正确</span><br><span class="line">    Time:14 ms</span><br><span class="line">    Memory:2192 kb</span><br><span class="line">****************************************************************/</span><br></pre></td></tr></table></figure>

<hr>
<p><a id="D"><font color="black" size="5"><strong>D. Flag - From CodeForces 16A</strong></font></a></p>
<p>原题地址：<a href="https://codeforces.com/problemset/problem/16/A">https://codeforces.com/problemset/problem/16/A</a></p>
<p><img src="http://ys-c.ysepan.com/544024545/713499361/kibtqyq35683T64KHMXJd2/20230309D1.png" alt="D题题面"><br><img src="http://ys-c.ysepan.com/544024546/713499362/l49562V56GIQWIkibtqyd7/20230309D2.png" alt="D题样例"></p>
<p>签到题，没什么好说的。</p>
<p>本题AC代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    char x[105][105];</span><br><span class="line">    int n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x[i];</span><br><span class="line">        if(i!=1&amp;&amp;x[i][0]==x[i-1][0])&#123;</span><br><span class="line">            cout&lt;&lt;&quot;NO&quot;;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=1;j&lt;m;j++)&#123;</span><br><span class="line">            if(x[i][j]!=x[i][j-1])&#123;</span><br><span class="line">                cout&lt;&lt;&quot;NO&quot;;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;YES&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/**************************************************************</span><br><span class="line">    Problem: 3663</span><br><span class="line">    User: 123 [URright]</span><br><span class="line">    Language: C++</span><br><span class="line">    Result: 正确</span><br><span class="line">    Time:13 ms</span><br><span class="line">    Memory:2176 kb</span><br><span class="line">****************************************************************/</span><br></pre></td></tr></table></figure>

<hr>
<p><a id="E"><font color="black" size="5"><strong>E. Smart Boy - From CodeForces 38F</strong></font></a></p>
<p>原题地址：<a href="https://codeforces.com/problemset/problem/38/F">https://codeforces.com/problemset/problem/38/F</a></p>
<p><img src="http://ys-c.ysepan.com/544024518/713499374/q76273W3467N2kfeupu16/20230309E1.png" alt="E题题面"><br><img src="http://ys-c.ysepan.com/544024518/713499375/q76273W3467N3kfeupu23/20230309E2.png" alt="E题样例"></p>
<p>被中间的得分公式吓到了，所以没仔细看题目。<br><del>（估计看了也写不出来罢）</del><br>题目大意：两个玩家为了玩一个叫聪明男孩的游戏创建了一个含有n个单词的词典，然后他们轮流从空字符串开始构造字符串，必须选择词典中某个单词用到的字母且必须只能加在字符串的开头或结尾，构造完后若该字符串是词典中某个单词的子串则获得分数，否则该玩家失败。分数公式中value(字母)返回该字母为字母表中第几个，nums(s)为词典中中以s为子串的字符串数量。每个人在操作时采取最优策略让自己赢，且在保证自己赢的情况下使得自己得分最高，在保证自己赢且得分最高的情况下使得对方得分尽可能少，问最后谁会赢以及两个人的得分各是多少。</p>
<p>在网上找了一下题解，似乎只要预处理每个子串的和然后记忆化搜索就能解出来了。具体代码思路还得研究研究。</p>
<p>本题AC代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">#include &lt;cstdio&gt;  </span><br><span class="line">#include &lt;cstring&gt;  </span><br><span class="line">#include &lt;string&gt;  </span><br><span class="line">#include &lt;algorithm&gt;  </span><br><span class="line">#include &lt;map&gt;  </span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;stack&gt;  </span><br><span class="line">#include &lt;queue&gt;  </span><br><span class="line">#include &lt;vector&gt;  </span><br><span class="line">#include &lt;bitset&gt;  </span><br><span class="line">#include &lt;functional&gt;  </span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define LL long long</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line"> </span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">	int sg, sum1, sum2;</span><br><span class="line">	bool operator &lt; (const node &amp;x)const</span><br><span class="line">	&#123;</span><br><span class="line">		if (sg != x.sg) return sg &lt; x.sg;</span><br><span class="line">		if (sum1 != x.sum1) return sum1 &lt; x.sum1;</span><br><span class="line">		return sum2 &gt; x.sum2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">set&lt;string&gt;S;</span><br><span class="line">map&lt;string, node&gt;mp;</span><br><span class="line">map&lt;string, int&gt;num;</span><br><span class="line"> </span><br><span class="line">int get(string s)</span><br><span class="line">&#123;</span><br><span class="line">	int ans = 0, mx = 0, len = s.length();</span><br><span class="line">	for (int i = 0; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans += s[i] - &#x27;a&#x27; + 1;</span><br><span class="line">		mx = max(mx, s[i] - &#x27;a&#x27; + 1);</span><br><span class="line">	&#125;</span><br><span class="line">	return ans * mx + num[s];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">node dfs(string s)</span><br><span class="line">&#123;</span><br><span class="line">	if (mp.find(s) != mp.end()) return mp[s];</span><br><span class="line">	node ans = &#123; 0, 0, 0 &#125;;</span><br><span class="line">	for (int i = 0; i &lt; 26; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		string ss = s + char(&#x27;a&#x27; + i);</span><br><span class="line">		if (S.find(ss) != S.end())</span><br><span class="line">		&#123;</span><br><span class="line">			node tmp = dfs(ss);</span><br><span class="line">			swap(tmp.sum1, tmp.sum2);</span><br><span class="line">			tmp.sg ^= 1;</span><br><span class="line">			tmp.sum1 += get(ss);</span><br><span class="line">			if (ans &lt; tmp) ans = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		ss = char(&#x27;a&#x27; + i) + s;</span><br><span class="line">		if (S.find(ss) != S.end())</span><br><span class="line">		&#123;</span><br><span class="line">			node tmp = dfs(ss);</span><br><span class="line">			swap(tmp.sum1, tmp.sum2);</span><br><span class="line">			tmp.sg ^= 1;</span><br><span class="line">			tmp.sum1 += get(ss);</span><br><span class="line">			if (ans &lt; tmp) ans = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return mp[s] = ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, len;</span><br><span class="line">	string s, ss;</span><br><span class="line">	while (~scanf(&quot;%d&quot;, &amp;n))</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i = 1; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; s;</span><br><span class="line">			set&lt;string&gt;tmp;</span><br><span class="line">			len = s.length();</span><br><span class="line">			for (int j = 0; j &lt; len; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				for (int k = j; k &lt; len; k++)</span><br><span class="line">				&#123;</span><br><span class="line">					ss = s.substr(j, k - j + 1);</span><br><span class="line">					S.insert(ss);</span><br><span class="line">					if (tmp.find(ss) == tmp.end())</span><br><span class="line">					&#123;</span><br><span class="line">						tmp.insert(ss);</span><br><span class="line">						num[ss]++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		node ans = dfs(&quot;&quot;);</span><br><span class="line">		if (ans.sg) printf(&quot;First\n&quot;);</span><br><span class="line">		else printf(&quot;Second\n&quot;);</span><br><span class="line">		printf(&quot;%d %d\n&quot;, ans.sum1, ans.sum2);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码原文链接：<a href="https://blog.csdn.net/a664607530/article/details/79844768">https://blog.csdn.net/a664607530/article/details/79844768</a></p>
<hr>
<p><a id="F"><font color="black" size="5"><strong>F. Airport - From CodeForces 218B</strong></font></a></p>
<p>原题地址：<a href="https://codeforces.com/problemset/problem/218/B">https://codeforces.com/problemset/problem/218/B</a></p>
<p><img src="http://ys-k.ysepan.com/544024542/713499999/h665436633KNL3kibtqybc/20230309F1.png" alt="F题题面"><br><img src="http://ys-k.ysepan.com/544024542/713500000/h665436633KNL4kibtqy2d/20230309F2.png" alt="F题样例"></p>
<p>又是一道拿下手刹的题，感谢zjk的快速翻译，三人一起讨论了之后马上有思路了，代码一气呵成。<br>题意是输入乘客数n和飞机数m，再输入m个数代表飞机上的位置数和价格，价格会随着位置数的减少同时降低，例如有2个位置时是2块钱，有1个位置时就是1块，要求输出搭乘这几架飞机能赚到的最大值和最小值。</p>
<p>思路也很清晰，输入桶排后取座位数的最大值和最小值，然后依次向上&#x2F;向下遍历，循环乘客数量次后跳出循环输出结果。</p>
<p>本题AC代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int seatmax[1005]=&#123;0&#125;,seatmin[1005]=&#123;0&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n1,n2,plane,s,maxn=0,minn=1005;</span><br><span class="line">    cin&gt;&gt;n1&gt;&gt;plane;</span><br><span class="line">    n2=n1;</span><br><span class="line">    for(int i=1;i&lt;=plane;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        seatmax[s]++;</span><br><span class="line">        seatmin[s]++;</span><br><span class="line">        if(maxn&lt;s)maxn=s;</span><br><span class="line">        if(minn&gt;s)minn=s;</span><br><span class="line">    &#125;</span><br><span class="line">    int resulta=0,resultb=0;</span><br><span class="line">    while(n1&gt;0)&#123;</span><br><span class="line">        while(seatmax[maxn]==0)&#123;</span><br><span class="line">            maxn--;</span><br><span class="line">        &#125;</span><br><span class="line">        resulta+=maxn;</span><br><span class="line">        seatmax[maxn]--;</span><br><span class="line">        seatmax[maxn-1]++;</span><br><span class="line">        n1--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;resulta&lt;&lt;&quot; &quot;;</span><br><span class="line">    while(n2&gt;0)&#123;</span><br><span class="line">        while(seatmin[minn]==0)&#123;</span><br><span class="line">            minn++;</span><br><span class="line">        &#125;</span><br><span class="line">        resultb+=minn;</span><br><span class="line">        seatmin[minn]--;</span><br><span class="line">        seatmin[minn-1]++;</span><br><span class="line">        if(minn!=1)minn=minn-1;</span><br><span class="line">        n2--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;resultb;</span><br><span class="line">&#125;</span><br><span class="line">/**************************************************************</span><br><span class="line">    Problem: 3504</span><br><span class="line">    User: 123 [URright]</span><br><span class="line">    Language: C++</span><br><span class="line">    Result: 正确</span><br><span class="line">    Time:13 ms</span><br><span class="line">    Memory:2184 kb</span><br><span class="line">****************************************************************/</span><br></pre></td></tr></table></figure>

<hr>
<p><a id="G"><font color="black" size="5"><strong>G. Three Arrays - From CodeForces 392D</strong></font></a></p>
<p>原题地址：<a href="https://codeforces.com/problemset/problem/392/D">https://codeforces.com/problemset/problem/392/D</a></p>
<p><img src="http://ys-f.ysepan.com/544024516/713503163/n4956354MF3Q73kfeupu5e/20230309G1.png" alt="G题题面"><br><img src="http://ys-f.ysepan.com/544024516/713503164/n4956354MF3Q74kfeupu68/20230309G2.png" alt="G题样例"></p>
<p>找了半天，最后在别人的cf的博客里找到了题解。<br>题解链接：<a href="https://codeforces.com/blog/entry/83942">https://codeforces.com/blog/entry/83942</a></p>
<p>假设某个数k在b中只出现一次，在c中只出现了一次，并且b[i]&#x3D;c[j]&#x3D;k。然后我们表示pos[i]&#x3D;j。现在，如果k在c中有多次出现，我们将取最小的j。如果它在b中有多次发生，我们将第一个pos[i]设置为j，其他设置为0。现在问题的答案是mini（（i−1）+maxj&gt;ipos[j]）。括号中的表达式对应于我们从b中取i个元素时的情况。然后我们查找所有其他元素（j&gt;i），并选择包含所有这些元素的c的最短前缀。这解释了为什么我们将c中k的第一次出现写为pos。我们用零填充其他值，因为如果我们已经在b中出现了第一次，我们就不需要它们了。<br>现在回到有a的情况。如果a中有一些数字，会发生什么变化？那么，在这种情况下，我们可以为b中出现的所有数字设置pos[i]&#x3D;0（不仅仅是除第一个之外的所有数字）。这意味着，如果我们从0到n迭代a的前缀，那么我们将不得不将一些pos更改为零。但我更喜欢将零更改为某些值，因此我们将从n迭代到0。<br>假设我们决定不在a中使用长度为i的前缀，而是使用长度为i-1的前缀。如果i之前出现了一些a[i]，那么pos中没有任何变化。但是如果i之前没有a[i]，我们必须更新一些pos并重新计算mini（（i−1）+maxj&gt;ipos[j]）。我相信有不同的结构可以做到这一点，我将描述我所使用的。<br>在表达式中，后缀上有最大值。它们可以存储为对（p，m），这意味着后缀上的p最大值至少为m（显然，后缀上的最大值是一个非递增函数）。现在，为了计算答案，我们不必遍历所有i。我们只需要考虑这样的指数p，即集合中存在某对（p−1，？）。这意味着我们必须为每对相邻的对检查一个选项。记住，我们只需要向这个集合添加对。而且很容易——添加一对，并在它之前删除足够多的对（而它们的m小于新的m）。对于每个添加或删除，我们都有O（1）个选项的添加或删除。当前答案可以存储在多集合中，因为我们只需要最小值。如果我们看到a的前缀i，那么我们必须用i+（multiset中的最小值）更新答案。</p>
<p>本题AC代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; a(n), b(n), c(n);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; c[i];</span><br><span class="line"></span><br><span class="line">    for (auto k : c) &#123;</span><br><span class="line">        b.push_back(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map&lt;int, int&gt; whereb;</span><br><span class="line">    map&lt;int, int&gt; wherec;</span><br><span class="line">    for (int i = (int)b.size() - 1; i &gt;= 0; --i)</span><br><span class="line">        whereb[b[i]] = i;</span><br><span class="line">    for (int i = (int)c.size() - 1; i &gt;= 0; --i)</span><br><span class="line">        wherec[c[i]] = i;</span><br><span class="line"></span><br><span class="line">    vector&lt;bool&gt; first_in_a(a.size(), false);</span><br><span class="line">    vector&lt;bool&gt; first_in_b(b.size(), false);</span><br><span class="line">    set&lt;int&gt; ina, inb;</span><br><span class="line">    for (int i = 0; i &lt; a.size(); ++i) &#123;</span><br><span class="line">        if (!ina.count(a[i])) &#123;</span><br><span class="line">            ina.insert(a[i]);</span><br><span class="line">            first_in_a[i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; b.size(); ++i) &#123;</span><br><span class="line">        if (!inb.count(b[i])) &#123;</span><br><span class="line">            inb.insert(b[i]);</span><br><span class="line">            first_in_b[i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set&lt;pair&lt;int, int&gt;&gt; maxs;</span><br><span class="line">    multiset&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">    maxs.emplace(1e9, 0);</span><br><span class="line">    maxs.emplace(-1, 1e9 + 5);</span><br><span class="line">    res.insert(maxs.begin()-&gt;first + next(maxs.begin())-&gt;second + 1);</span><br><span class="line"></span><br><span class="line">    auto del = [&amp;](pair&lt;int, int&gt; p) &#123;</span><br><span class="line">        auto it = maxs.find(p);</span><br><span class="line">        assert(it != maxs.end());</span><br><span class="line">        auto inext = next(it);</span><br><span class="line">        auto iprev = prev(it);</span><br><span class="line"></span><br><span class="line">        res.erase(res.find(iprev-&gt;first + it-&gt;second + 1));</span><br><span class="line">        res.erase(res.find(it-&gt;first + inext-&gt;second + 1));</span><br><span class="line">        maxs.erase(it);</span><br><span class="line">        res.insert(iprev-&gt;first + inext-&gt;second + 1);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    auto add = [&amp;](pair&lt;int, int&gt; p) &#123;</span><br><span class="line">        auto it = maxs.lower_bound(make_pair(p.first, -5));</span><br><span class="line">        if (it-&gt;second &gt;= p.second) return;</span><br><span class="line">        if (it-&gt;first == p.first) &#123;</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">        while (prev(it)-&gt;second &lt;= p.second)</span><br><span class="line">            del(*prev(it));</span><br><span class="line"></span><br><span class="line">        maxs.insert(p);</span><br><span class="line">        it = maxs.find(p);</span><br><span class="line">        auto inext = next(it);</span><br><span class="line">        auto iprev = prev(it);</span><br><span class="line"></span><br><span class="line">        res.insert(iprev-&gt;first + it-&gt;second + 1);</span><br><span class="line">        res.insert(it-&gt;first + inext-&gt;second + 1);</span><br><span class="line">        res.erase(res.find(iprev-&gt;first + inext-&gt;second + 1));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; b.size(); ++i) &#123;</span><br><span class="line">        if (first_in_b[i] &amp;&amp; !ina.count(b[i])) &#123;</span><br><span class="line">            int inc = 1e9;</span><br><span class="line">            if (wherec.count(b[i]))</span><br><span class="line">                inc = wherec[b[i]] + 1;</span><br><span class="line">            add(&#123;i, inc&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans = n + *res.begin();</span><br><span class="line"></span><br><span class="line">    for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        if (first_in_a[i]) &#123;</span><br><span class="line">            if (!inb.count(a[i])) break;</span><br><span class="line">            int inc = 1e9;</span><br><span class="line">            if (wherec.count(a[i]))</span><br><span class="line">                inc = wherec[a[i]] + 1;</span><br><span class="line">            add(&#123;whereb[a[i]], inc&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = min(ans, i + *res.begin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><a id="H"><font color="black" size="5"><strong>H. Sockets - From CodeForces 257A</strong></font></a></p>
<p>原题地址：<a href="https://codeforces.com/problemset/problem/257/A">https://codeforces.com/problemset/problem/257/A</a></p>
<p><img src="http://ys-f.ysepan.com/544024540/713503186/r5546623NK3M6Kkibtqy84/20230309H1.png" alt="H题题面"><br><img src="http://ys-f.ysepan.com/544024540/713503187/r5546623NK3M6Lkibtqyac/20230309H2.png" alt="H题样例"></p>
<p>纯水题，更离谱的是这道题最后有人做出来之后才陆陆续续做出来，大家都没发现。<br>一开始看这题的也是我，吃了没文化的大亏呜呜呜。结果三个人一起看才看懂。<br>有n条插板，m个设备和k个固定插孔，n条插板上各有an个插孔，问最少需要几个插板能让所有设备通电，不能则输出-1。<br>很简单的一题，先让每个插孔数-1，然后排序，再从大到小一个个加，加到插孔数超过设备数后停下来。最后输出插板数。</p>
<p>本题AC代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,k,x0,i;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    int x[55];</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x0;</span><br><span class="line">        x[i]=x0-1;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(x,x+n);</span><br><span class="line">    if(m&lt;=k)&#123;</span><br><span class="line">        cout&lt;&lt;0;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int re=0;</span><br><span class="line">    for(i=n-1;i&gt;=0;i--)&#123;</span><br><span class="line">        k+=x[i];</span><br><span class="line">        re++;</span><br><span class="line">        if(k&gt;=m)&#123;</span><br><span class="line">            cout&lt;&lt;re;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i&lt;0)cout&lt;&lt;-1;</span><br><span class="line">&#125;</span><br><span class="line">/**************************************************************</span><br><span class="line">    Problem: 3383</span><br><span class="line">    User: 123 [URright]</span><br><span class="line">    Language: C++</span><br><span class="line">    Result: 正确</span><br><span class="line">    Time:13 ms</span><br><span class="line">    Memory:2176 kb</span><br><span class="line">****************************************************************/</span><br></pre></td></tr></table></figure>
<p>属于是很紧张了，最后15分钟发现这题，然后用了5分钟一气呵成。哈人。</p>
<hr>
<p><a id="I"><font color="black" size="5"><strong>I. Apple Tree - From CodeForces 349D</strong></font></a></p>
<p>原题地址：<a href="https://codeforces.com/contest/349/problem/D">https://codeforces.com/contest/349/problem/D</a></p>
<p><img src="http://ys-f.ysepan.com/544024540/713503198/r5546623O54MI4kibtqy32/20230309I1.png" alt="I题题面"><br><img src="http://ys-f.ysepan.com/544024540/713503199/r5546623O54MI5kibtqyba/20230309I2.png" alt="I题样例"></p>
<p>比赛的时候稍稍看了眼这道题，但还是败在了英语上，所以没做下去。<br>题意其实也很简单，给一颗树，每个叶子结点上都有苹果，要求相同高度的每个结点上所拥有的苹果数相等，求最少应该摘掉几个苹果才能满足这个条件。<br>我们不妨做个假设：一棵树根节点有3个儿子，每个儿子分别又有2，3，4个儿子（假设他们全是叶子结点且上面都有苹果），那么相当于要分别分2，3，4个苹果给这些孙子。又因为每个分支需要分到的苹果数量相等，所以可以求出他们的最小公倍数lcm，例如每个节点12个，这样就能满足每个分支苹果数量相等了；若取最大值，就是先求出这个分支的苹果总数sum[i]，再减去sum[i]%lcm使之成为lcm的整数倍，就能得到最大值了。运用dfs向根节点递归即可得到答案。</p>
<p>本题AC代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n,a[200005];//a为每个节点本身的苹果数量 </span><br><span class="line">ll sum[200005],cnt[200005];//sum为每个节点下的苹果总数，cnt为每个节点的分支数 </span><br><span class="line">vector&lt;int&gt;g[200005];//连接的节点有哪些，第一个是父节点，后面的都是子节点 </span><br><span class="line">ll gcd(ll a,ll b)</span><br><span class="line">&#123;</span><br><span class="line">    return b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line">ll lcm(ll a,ll b)</span><br><span class="line">&#123;</span><br><span class="line">    return a/gcd(a,b)*b;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int u,int fa)//节点和父节点 </span><br><span class="line">&#123;</span><br><span class="line">    int next=0;</span><br><span class="line">    for(int i=0;i&lt;(int)g[u].size();i++)&#123;</span><br><span class="line">        int v=g[u][i];</span><br><span class="line">        if(v==fa) continue;//遇到父节点跳过</span><br><span class="line">        dfs(v,u);</span><br><span class="line">        if(!next)&#123;</span><br><span class="line">            sum[u]=sum[v];</span><br><span class="line">            cnt[u]=cnt[v];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            if(cnt[u]&lt;5e13) cnt[u]=lcm(cnt[u],cnt[v]);</span><br><span class="line">            sum[u]=min(sum[u],sum[v])/cnt[u]*cnt[u];</span><br><span class="line">        &#125;</span><br><span class="line">        next++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!next)&#123;//叶子结点</span><br><span class="line">        sum[u]=a[u];cnt[u]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;//非叶子结点 </span><br><span class="line">        sum[u]*=next;</span><br><span class="line">        if(cnt[u]&lt;5e13) cnt[u]*=next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    ll ans=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">        ans+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int x,y;</span><br><span class="line">    for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">        g[x].push_back(y);</span><br><span class="line">        g[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    dfs(1,0);</span><br><span class="line">    cout&lt;&lt;ans-sum[1];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><a id="J"><font color="black" size="5"><strong>J. Game with Strings - From CodeForces 354B</strong></font></a></p>
<p>原题地址：<a href="https://codeforces.com/contest/354/problem/B">https://codeforces.com/contest/354/problem/B</a></p>
<p><img src="http://ys-j.ysepan.com/544024539/713503679/lgfsmzu554662498HMMI64/20230309J1.png" alt="J题题面"><br><img src="http://ys-j.ysepan.com/544024539/713503680/lgfsmzu554662498HMMJ95/20230309J2.png" alt="J题样例"></p>
<p>网上找不到题解，但是有源代码，于是试着理解了一下。<br>大致意思是两个人从空字符串开始玩拼字符游戏，拼上去的字母需满足：加上该字母所得的新字符串必须为某个矩阵中从左上到右下拼成的所有可能的字符串的其中一种。拼到最后如果字母a的数量比b多则输出FIRST，比a少输出SECOND，相等输出DRAW。两个人都要尽可能赢所以需要走最佳状况。<br>首先建个二维的dp数组。第一维表示走到第几步。可以画一个正方形，以左上角斜着划线，第i步走的点只能是第i条线上的点；第二维表示第i步可以到达的点的状态。接着另开一个a数组来表示第i条线上每个字母的状态。dp所代表的值就为a与b的差值，并以此进行记忆化操作。</p>
<p>本题AC代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define LL __int64</span><br><span class="line">#define INF 1e9</span><br><span class="line">int dp[42][1&lt;&lt;20],a[42][42];</span><br><span class="line">char s[22][22];</span><br><span class="line">int n;</span><br><span class="line">int dfs(int step,int sta)</span><br><span class="line">&#123;</span><br><span class="line">    int i,num=0;</span><br><span class="line">    if(dp[step][sta]!=INF)</span><br><span class="line">    return dp[step][sta];</span><br><span class="line">    for(i = 0; i &lt; n ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(sta&amp;(1&lt;&lt;i))</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[step-i][i]==&#x27;a&#x27;) num++;</span><br><span class="line">            else if(s[step-i][i]==&#x27;b&#x27;) num--;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(step==2*n-2)</span><br><span class="line">    return dp[step][sta] = num;</span><br><span class="line">    if(step%2!=0)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[step][sta] = -INF;</span><br><span class="line">        for(i = 0 ; i &lt; 26 ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int next = a[step+1][i]&amp;(sta|(sta&lt;&lt;1));</span><br><span class="line">            if(next==0)</span><br><span class="line">            continue;</span><br><span class="line">            dp[step][sta] = max(dp[step][sta],dfs(step+1,next)+num);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[step][sta];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for(i = 0 ; i &lt; 26 ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int next = a[step+1][i]&amp;(sta|(sta&lt;&lt;1));</span><br><span class="line">            if(next==0)</span><br><span class="line">            continue;</span><br><span class="line">            dp[step][sta] = min(dp[step][sta],dfs(step+1,next)+num);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[step][sta];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(i = 0 ; i &lt; n ; i++)</span><br><span class="line">    cin&gt;&gt;s[i];</span><br><span class="line">    for(i = 0 ; i &lt; 2*n-1 ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j = 0 ; j &lt; n ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i-j&lt;0||i-j&gt;=n) continue;</span><br><span class="line">            a[i][s[i-j][j]-&#x27;a&#x27;] |= (1&lt;&lt;j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i = 0 ; i &lt; 2*n ; i++)</span><br><span class="line">        for(j = 0 ; j &lt; (1&lt;&lt;n) ; j++)</span><br><span class="line">        dp[i][j] = INF;</span><br><span class="line">    int ans = dfs(0,1);</span><br><span class="line">    if(ans&gt;0)</span><br><span class="line">    puts(&quot;FIRST&quot;);</span><br><span class="line">    else if(ans&lt;0)</span><br><span class="line">    puts(&quot;SECOND&quot;);</span><br><span class="line">    else</span><br><span class="line">    puts(&quot;DRAW&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><font size="6"><strong>写在最后</strong></font></p>
<p>没想到大二第二个学期这么快就开始了。这也是这个学期的第一次ACM校赛，拿到这个成绩也是意料之外情理之中。寒假由于父亲的身体原因，本想着认真学一个寒假的算法，结果因为住院陪同而没能完整学下去。不过好在后来报了Namomo Winter Camp，或多或少学了些东西进去。但开学后又把算法忘得一干二净，等期末考完后再次拿起算法书发现已经生分了许多。</p>
<p>但只要想学习，总是有机会学的，所以归根结底还是得从自己身上找原因。把这次比赛当做一个教训，在接下来的日子里努力学算法，刷题打cf，不求做得最好，只求尽力而为。正如dls在开营仪式中所说的，“仰望星空，脚踏实地。”接下来一步一个脚印，心无旁骛，抬头看路，足矣。</p>
<p>接下来的蓝桥杯省赛和天梯赛继续加油啦。<br>如果还有第二次ACM选拔赛，希望能拿下。当然尽力而为才是最大的胜利。</p>
<p>2023&#x2F;03&#x2F;12 00:51 于201寝室</p>
]]></content>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>DarkBug的完美算法教室01：并查集的使用</title>
    <url>/2023/04/07/SF01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><font size="6"><strong>前情提要</strong></font></p>
<p>3月16号学校组织了一场天梯模拟赛，其中有一大半高分题都涉及到集合问题。事后跑去洛谷做集合的题单，发现了一个短小精悍神秘而优雅的东西——<strong>并查集</strong>。</p>
<p>了解了这是个什么玩意并练了几道题之后，<del>九敏家人们谁懂啊我好像恋爱了</del></p>
<hr>
<p><font size="6"><strong>并查集的实现</strong></font></p>
<p>并查集是一种树型的数据结构，用于处理一些不相交集合（disjoint sets）的合并及查询问题。常常在使用中以森林来表示。（转自百度百科）</p>
<p>实现主要由两个步骤组成：<strong>查找和合并</strong>。</p>
<p>查找代码（查找祖先）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int find(int x) &#123;</span><br><span class="line">    if(x != fa[x])//当x不等于它的爸爸时(当它是祖先时，它没有爸爸) </span><br><span class="line">    &#123;</span><br><span class="line">        fa[x] = find(fa[x]);//继续找他爸爸的爸爸 </span><br><span class="line">    &#125;</span><br><span class="line">    return fa[x];//返回祖先 </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>合并代码（将两个祖先结为父子）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void unity(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    int r1 = find(x);//找到x的祖先 </span><br><span class="line">    int r2 = find(y);//找到y的祖先 </span><br><span class="line">    fa[r1] = r2;//祖先和祖先结为父子，看题目需求，本代码y为x的祖先</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用并查集前还需要初始化fa数组，让每个结点的父亲等于其本身，即每个人都是祖先。<br>只需使用这两段代码即可解决大量关于集合之间关系的问题，<del>实在是太优雅了！</del></p>
<hr>
<p><font size="6"><strong>例题</strong></font></p>
<p><strong>SF01-01 家谱</strong> | <a href="https://www.luogu.com.cn/problem/P2814">https://www.luogu.com.cn/problem/P2814</a> </p>
<p>题目描述：<br>给出充足的父子关系，请你编写程序找到某个人的最早的祖先。</p>
<p>输入格式：<br>输入由多行组成，首先是一系列有关父子关系的描述，其中每一组父子关系中父亲只有一行，儿子可能有若干行，用 <code>#name</code> 的形式描写一组父子关系中的父亲的名字，用 <code>+name</code> 的形式描写一组父子关系中的儿子的名字；接下来用 <code>?name</code> 的形式表示要求该人的最早的祖先；最后用单独的一个 <code>$</code> 表示文件结束。</p>
<p>输出格式：<br>按照输入文件的要求顺序，求出每一个要找祖先的人的祖先，格式为：本人的名字 $+$ 一个空格 $+$ 祖先的名字 $+$ 回车。</p>
<p>样例输入 #1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#George</span><br><span class="line">+Rodney</span><br><span class="line">#Arthur</span><br><span class="line">+Gareth</span><br><span class="line">+Walter</span><br><span class="line">#Gareth</span><br><span class="line">+Edward</span><br><span class="line">?Edward</span><br><span class="line">?Walter</span><br><span class="line">?Rodney</span><br><span class="line">?Arthur</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>样例输出 #1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Edward Arthur</span><br><span class="line">Walter Arthur</span><br><span class="line">Rodney George</span><br><span class="line">Arthur Arthur</span><br></pre></td></tr></table></figure>

<p>提示：<br>规定每个人的名字都有且只有 $6$ 个字符，而且首字母大写，且没有任意两个人的名字相同。最多可能有 $10^3$ 组父子关系，总人数最多可能达到 $5 \times 10^4$ 人，家谱中的记载不超过 $30$ 代。</p>
<p>这道题key值是string，所以用map容器+并查集就能直接拿下。顺便复习了一下STL库的用法。</p>
<p>本题AC代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;string,string&gt; fa;</span><br><span class="line">string find(string x)&#123;</span><br><span class="line">	if(fa[x]!=x)fa[x]=find(fa[x]);</span><br><span class="line">	return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">int unite(string x,string y)&#123;</span><br><span class="line">	fa[find(y)]=find(x);//x的祖先为y的祖先的祖先</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	string x,father,son,check;</span><br><span class="line">	cin&gt;&gt;x;</span><br><span class="line">	while(x!=&quot;$&quot;)&#123;</span><br><span class="line">		if(x[0]==&#x27;#&#x27;)</span><br><span class="line">			father=x.substr(1);</span><br><span class="line">			if(!fa.count(father))&#123;</span><br><span class="line">				fa[father]=father;</span><br><span class="line">			&#125;</span><br><span class="line">		else if(x[0]==&#x27;+&#x27;)&#123;</span><br><span class="line">			son=x.substr(1);</span><br><span class="line">			if(!fa.count(son))&#123;</span><br><span class="line">				fa[son]=son;</span><br><span class="line">			&#125;</span><br><span class="line">			unite(father,son);//根据题意和代码设计，父亲放在前面孩子放在后面</span><br><span class="line">		&#125;</span><br><span class="line">		else if(x[0]==&#x27;?&#x27;)&#123;</span><br><span class="line">			check=x.substr(1);</span><br><span class="line">			cout&lt;&lt;check&lt;&lt;&quot; &quot;&lt;&lt;find(check)&lt;&lt;endl;</span><br><span class="line">		&#125; </span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>SF01-02 [BOI2003]团伙</strong> | <a href="https://www.luogu.com.cn/problem/P1892">https://www.luogu.com.cn/problem/P1892</a></p>
<p>题目描述：<br>现在有 $n$ 个人，他们之间有两种关系：朋友和敌人。我们知道：</p>
<ul>
<li>一个人的朋友的朋友是朋友</li>
<li>一个人的敌人的敌人是朋友</li>
</ul>
<p>现在要对这些人进行组团。两个人在一个团体内当且仅当这两个人是朋友。请求出这些人中最多可能有的团体数。</p>
<p>输入格式：<br>第一行输入一个整数 $n$ 代表人数。<br>第二行输入一个整数 $m$ 表示接下来要列出 $m$ 个关系。<br>接下来 $m$ 行，每行一个字符 $opt$ 和两个整数 $p,q$，分别代表关系（朋友或敌人），有关系的两个人之中的第一个人和第二个人。其中 $opt$ 有两种可能：</p>
<ul>
<li>如果 $opt$ 为 <code>F</code>，则表明 $p$ 和 $q$ 是朋友。</li>
<li>如果 $opt$ 为 <code>E</code>，则表明 $p$ 和 $q$ 是敌人。</li>
</ul>
<p>输出格式：<br>一行一个整数代表最多的团体数。</p>
<p>样例输入 #1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">4</span><br><span class="line">E 1 4</span><br><span class="line">F 3 5</span><br><span class="line">F 4 6</span><br><span class="line">E 1 2</span><br></pre></td></tr></table></figure>

<p>样例输出 #1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>提示：<br>对于 $100%$ 的数据，$2 \le n \le 1000$，$1 \le m \le 5000$，$1 \le p,q \le n$。</p>
<p>这道题稍微绕了个弯子，朋友的朋友是朋友，敌人的敌人也是朋友。所以就按着题意来，定义一个敌人数组，用于存放某个人的某个敌人是谁（只用记录其中一个即可）。若输入了A和B互为敌人，先检查A之前是否定义过了敌人，若定义过了，就让A的敌人和B合并；若B定义过了敌人，就让B的敌人和A合并；若两者都没有定义过敌人，就定义A的敌人是B，B的敌人是A。输入朋友信息的代码就与一般的并查集如出一辙了，本题重点在于解决敌人的敌人是朋友的问题。</p>
<p>本题AC代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">int enemy[5005],friends[5005];</span><br><span class="line">map&lt;int,int&gt; mm;</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">	if(friends[x]!=x)friends[x]=find(friends[x]);</span><br><span class="line">	return friends[x];</span><br><span class="line">&#125;</span><br><span class="line">int unite(int p,int q)&#123;</span><br><span class="line">	friends[find(p)]=find(q);</span><br><span class="line">&#125;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		enemy[i]=i;</span><br><span class="line">		friends[i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		string x;</span><br><span class="line">		int q,p;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;p&gt;&gt;q;</span><br><span class="line">		if(x==&quot;F&quot;)&#123;</span><br><span class="line">			unite(p,q);</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			if(enemy[p]!=p)&#123;</span><br><span class="line">				unite(enemy[p],q);</span><br><span class="line">			&#125;</span><br><span class="line">			else if(enemy[q]!=q)&#123;</span><br><span class="line">				unite(p,enemy[q]);</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				enemy[p]=q;</span><br><span class="line">				enemy[q]=p;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int ans=0;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		int father = find(i);</span><br><span class="line">		if(!mm.count(father))&#123;</span><br><span class="line">			ans++;</span><br><span class="line">			mm[father]=1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><font size="6"><strong>总结</strong></font></p>
<p>想不出结尾了，那我就夸一声并查集牛逼吧。哈哈！<br>还有一点要注意的是，要想计算一共有多少个相互独立的集合的话，只需要将所有祖父值遍历一遍即可，祖父值出现个数即为集合数。（怕自己一时半会儿脑子转不过来还是写一下吧）</p>
<p>作为完美算法教室系列的开端，在这里祝以后看到这句话的自己勿忘初心，不要忘了你是从何开始、如何开始走上算法这条不归路的。也希望你能够一直坚定不移地走下去，发现算法之美。<del>打阿卡伊双星不了那打cf给老子变成红名不过分吧！？</del></p>
<p><font size="4"><strong>——END——</strong></font></p>
]]></content>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>DarkBug的完美算法教室02：STL常用容器</title>
    <url>/2023/04/11/SF02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>呃啊封面放错了，不好意思，应该是这张↓，无视上面不知道哪个路人说的话<br><img src="http://ys-i.ysepan.com/544024549/713582975/kibtqyu554H5J3O8JM5Ia6/20230408cover2.jpg" alt="看不懂但大受震撼的STL容器图"></p>
<p><font size="6"><strong>小趣事</strong></font></p>
<p>上次本来想写一篇关于STL容器整理的博客（结果变成了并查集），那天参加了蓝桥杯想用vector容器的时候状态不佳（？）突然忘记名字了，于是对着键盘发呆了一会儿，一排排看着键盘上的字母试图唤起回忆，结果看到v这个字母真的立马想起来叫vector。属实没绷住。<br>加上自己的做题速度实在太慢了，其中有一部分时间又浪费在自己没能熟练掌握STL容器的各种函数方法，比如有道题用到了map，我试了5分钟左右才试出迭代器it指向的key值应该写作 <code>it-&gt;first</code> 。太浪费时间了。<del>有这5分钟时间我就能多睡5分钟了可恶啊</del><br>因此，作为天天被各种容器牵着绳子溜着走的人，<del>我觉得有必要介绍一下自己的主人们有哪些特性。</del></p>
<p><font size="6"><strong>目录</strong></font></p>
<ul>
<li><a href="#1">①STL容器适配器</a></li>
<li><a href="#2">②STL序列式容器</a></li>
<li><a href="#3">③STL关联式容器</a></li>
<li><a href="#4">④STL迭代器</a></li>
</ul>
<hr>
<hr>
<p><a id="1"><font size="6"><strong>①STL容器适配器</strong></font></a></p>
<hr>
<p><font size="6"><strong>Stack</strong></font></p>
<p>头文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stack&gt;</span><br></pre></td></tr></table></figure>

<p>构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stack&lt;T&gt; stk;</span><br></pre></td></tr></table></figure>

<p>数据存取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push(elem);//向栈顶添加元素 </span><br><span class="line">pop();//从栈顶移除第一个元素 </span><br><span class="line">top();//返回栈顶元素</span><br><span class="line">swap(stk);//交换两个堆栈的元素</span><br></pre></td></tr></table></figure>

<p>大小操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">empty();//判断堆栈是否为空 </span><br><span class="line">size();//返回堆栈的大小</span><br></pre></td></tr></table></figure>
<hr>
<p><font size="6"><strong>Queue</strong></font></p>
<p>头文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;queue&gt;</span><br></pre></td></tr></table></figure>

<p>构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">queue&lt;T&gt; queT;</span><br></pre></td></tr></table></figure>

<p>数据存取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push(elem);//向队尾添加元素 </span><br><span class="line">pop();//从队列头部移除第一个元素 </span><br><span class="line">front();//返回队列中第一个元素</span><br><span class="line">back();//返回队列中最后一个元素</span><br><span class="line">swap(que);//交换两个队列的元素</span><br></pre></td></tr></table></figure>

<p>大小操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">empty();//判断队列是否为空 </span><br><span class="line">size();//返回队列的大小</span><br></pre></td></tr></table></figure>

<p><font size="5"><strong>Priority_Queue</strong></font></p>
<p>和Queue的区别是，Priority_Queue是优先队列。它和普通队列的区别在于，优先队列的队头元素总是最大的——即执行 pop 操作时，删除的总是最大的元素；执行 top 操作时，返回的是最大元素的引用。</p>
<p>构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;T&gt; queT;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<p><a id="2"><font size="6"><strong>②STL序列式容器</strong></font></a></p>
<hr>
<p><font size="6"><strong>Array</strong></font></p>
<p>头文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;array&gt;</span><br></pre></td></tr></table></figure>

<p>构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array&lt;T,N&gt; arr;//N是常量，不能用变量表示</span><br></pre></td></tr></table></figure>

<p>数据存取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">front();//返回数组中第一个元素</span><br><span class="line">back();//返回数组中最后一个元素</span><br><span class="line">at(n);//返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。</span><br><span class="line">arr.at(n)=n;arr[n]=n;//赋值</span><br><span class="line">fill(n);//用指定值填充数组中所有元素</span><br></pre></td></tr></table></figure>

<p>大小操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">empty();//判断array是否为空 </span><br><span class="line">size();//返回容器中当前元素的数量</span><br><span class="line">max_size();//返回容器可容纳元素的最大数量</span><br></pre></td></tr></table></figure>

<hr>
<p><font size="6"><strong>Vector</strong></font></p>
<p>头文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br></pre></td></tr></table></figure>

<p>构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;T&gt; vec;</span><br><span class="line">vec.reserve(20);//增加vector的容量</span><br><span class="line">vector&lt;int&gt; primes&#123;2, 3, 5, 7, 11, 13, 17, 19&#125;;//初始带8个质数</span><br><span class="line">vector&lt;double&gt; values(20);//初始就有20个元素，值均为0</span><br><span class="line">vector&lt;double&gt; values(20, 1.0);//初始就有20个元素，值均为1.0。括号两个数既能是常量又能是变量</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;char&gt;value1(5, &#x27;c&#x27;);</span><br><span class="line">vector&lt;char&gt;value2(value1);//将value1的值赋给value2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int array[]=&#123;1,2,3&#125;;</span><br><span class="line">vector&lt;int&gt;values(array, array+2);//values 将保存&#123;1,2&#125;</span><br><span class="line">vector&lt;int&gt;value1&#123;1,2,3,4,5&#125;;</span><br><span class="line">vector&lt;int&gt;value2(begin(value1),begin(value1)+3);//value2保存&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure>

<p>数据存取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">front();//返回数组中第一个元素</span><br><span class="line">back();//返回数组中最后一个元素</span><br><span class="line">at(n);//使用经过边界检查的索引访问元素。</span><br><span class="line">vec[n]=n;//赋值</span><br><span class="line">push_back();在序列的尾部添加一个元素。</span><br><span class="line">pop_back();移出序列尾部的元素。</span><br><span class="line">it=vec.begin();</span><br><span class="line">vec.insert(it,5);//在第一个元素前面插入5</span><br><span class="line">erase();//移出一个元素或一段元素。</span><br><span class="line">clear();//移出所有的元素，容器大小变为 0。</span><br><span class="line">swap();//交换两个容器的所有元素。</span><br></pre></td></tr></table></figure>

<p>大小操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">empty();//判断vector是否为空 </span><br><span class="line">size();//返回容器中当前元素的数量</span><br><span class="line">max_size();//返回容器可容纳元素的最大数量</span><br></pre></td></tr></table></figure>

<p><font size="5"><strong>Deque</strong></font></p>
<p>和Vector的区别是，Deque支持在数组的开头和末尾插入或删除元素。</p>
<p>头文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;deque&gt;</span><br></pre></td></tr></table></figure>

<p>构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deque &lt;int&gt; dyarr1(5,10); //初始化数组5个元素都是10 </span><br></pre></td></tr></table></figure>

<p>数据存取（比Vector多了个front）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dyarr1.push_front(100);//在数组开头插入100</span><br><span class="line">dyarr1.pop_front();//删除数组开头的元素</span><br></pre></td></tr></table></figure>

<hr>
<p><font size="6"><strong>List</strong></font></p>
<p>头文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;list&gt;</span><br></pre></td></tr></table></figure>

<p>构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list&lt;T&gt; values;</span><br><span class="line">list&lt;int&gt; values(10);//包含10个元素，值为0</span><br><span class="line">list&lt;int&gt; values(10, 5);//包含10个元素，值为5</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::list&lt;int&gt; value1(10);</span><br><span class="line">std::list&lt;int&gt; value2(value1);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a[] = &#123; 1,2,3,4,5 &#125;;</span><br><span class="line">list&lt;int&gt; values(a, a+5);</span><br><span class="line">array&lt;int, 5&gt;arr&#123; 11,12,13,14,15 &#125;;</span><br><span class="line">list&lt;int&gt;values(arr.begin()+2, arr.end());//拷贝其它类型的容器，创建 list 容器，拷贝arr容器中的&#123;13,14,15&#125;</span><br></pre></td></tr></table></figure>

<p>数据存取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">front();//返回数组中第一个元素</span><br><span class="line">back();//返回数组中最后一个元素</span><br><span class="line">emplace_front();//在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。</span><br><span class="line">push_front();//在容器头部插入一个元素。</span><br><span class="line">pop_front();//删除容器头部的一个元素。</span><br><span class="line">emplace_back();//在容器尾部直接生成一个元素。该函数和 push_back() 的功能相同，但效率更高。</span><br><span class="line">push_back();//在容器尾部插入一个元素。</span><br><span class="line">pop_back();//删除容器尾部的一个元素。</span><br><span class="line">emplace();//在容器中的指定位置插入元素。该函数和 insert() 功能相同，但效率更高。</span><br><span class="line">insert();//在容器中的指定位置插入元素。</span><br><span class="line">erase();//删除容器中一个或某区域内的元素。</span><br><span class="line">swap();//交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。</span><br><span class="line">unique();//删除容器中相邻的重复元素，只保留一个。</span><br><span class="line">merge();//合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的。</span><br></pre></td></tr></table></figure>

<p>大小操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">empty();//判断list是否为空 </span><br><span class="line">size();//返回容器中当前元素的数量</span><br><span class="line">max_size();//返回容器可容纳元素的最大数量</span><br></pre></td></tr></table></figure>

<p><font size="5"><strong>Forward_List</strong></font></p>
<p>效率高是选用 forward_list 而弃用 list 容器最主要的原因，换句话说，只要是 list 容器和 forward_list 容器都能实现的操作，应优先选择 forward_list 容器。（转自C语言中文网的介绍）</p>
<p>头文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;forward_list&gt;</span><br></pre></td></tr></table></figure>

<p>数据存取（特殊）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emplace_after();//在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。和 insert_after() 的功能相同，但效率更高。</span><br><span class="line">insert_after();//在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。</span><br><span class="line">erase_after();//删除容器中某个指定位置或区域内的所有元素。</span><br></pre></td></tr></table></figure>

<hr>
<p><font size="6"><strong>Vector和List的区别</strong></font></p>
<p>关于随机访问：</p>
<p>vector支持随机访问，可以利用下标精准定位到一个元素上，访问某个元素的时间复杂度是O(1)。<br>list不支持随机访问，要想访问list中的某个元素只能是从前向后或从后向前依次遍历，时间复杂度是O(N)。</p>
<p>关于插入和删除：</p>
<p>vector任意位置插入和删除的效率低，因为它每插入一个元素（尾插除外），都需要搬移数据，时间复杂度是O(N)，而且插入还有可能要增容，这样一来还要开辟新空间，拷贝元素，是旧空间，效率会更低。<br>list任意位置插入和删除的效率高，他不需要搬移元素，只需要改变插入或删除位置的前后两个节点的指向即可，时间复杂度为O(1)。</p>
<hr>
<hr>
<p><a id="3"><font size="6"><strong>③STL关联式容器</strong></font></a></p>
<p><font size="5"><strong>附： pair类的使用</strong></font></p>
<p>头文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;utility&gt;</span><br></pre></td></tr></table></figure>

<p>使用样例（爱来自C语言中文网）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;utility&gt;      // pair</span><br><span class="line">#include &lt;string&gt;       // string</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    // 调用构造函数 1，也就是默认构造函数</span><br><span class="line">    pair &lt;string, double&gt; pair1;</span><br><span class="line">    // 调用第 2 种构造函数</span><br><span class="line">    pair &lt;string, string&gt; pair2(&quot;STL教程&quot;,&quot;http://c.biancheng.net/stl/&quot;);  </span><br><span class="line">    // 调用拷贝构造函数</span><br><span class="line">    pair &lt;string, string&gt; pair3(pair2);</span><br><span class="line">    //调用移动构造函数</span><br><span class="line">    pair &lt;string, string&gt; pair4(make_pair(&quot;C++教程&quot;, &quot;http://c.biancheng.net/cplus/&quot;));</span><br><span class="line">    // 调用第 5 种构造函数</span><br><span class="line">    pair &lt;string, string&gt; pair5(string(&quot;Python教程&quot;), string(&quot;http://c.biancheng.net/python/&quot;));  </span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; &quot;pair1: &quot; &lt;&lt; pair1.first &lt;&lt; &quot; &quot; &lt;&lt; pair1.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;pair2: &quot;&lt;&lt; pair2.first &lt;&lt; &quot; &quot; &lt;&lt; pair2.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;pair3: &quot; &lt;&lt; pair3.first &lt;&lt; &quot; &quot; &lt;&lt; pair3.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;pair4: &quot; &lt;&lt; pair4.first &lt;&lt; &quot; &quot; &lt;&lt; pair4.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;pair5: &quot; &lt;&lt; pair5.first &lt;&lt; &quot; &quot; &lt;&lt; pair5.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    pair1.first = &quot;Java教程&quot;;</span><br><span class="line">    pair1.second = &quot;http://c.biancheng.net/java/&quot;;</span><br><span class="line">    cout &lt;&lt; &quot;new pair1: &quot; &lt;&lt; pair1.first &lt;&lt; &quot; &quot; &lt;&lt; pair1.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    pair &lt;string, string&gt; pair4 = make_pair(&quot;C++教程&quot;, &quot;http://c.biancheng.net/cplus/&quot;);</span><br><span class="line">    cout &lt;&lt; &quot;pair4: &quot; &lt;&lt; pair4.first &lt;&lt; &quot; &quot; &lt;&lt; pair4.second &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pair1:  0</span><br><span class="line">pair2: STL教程 http://c.biancheng.net/stl/</span><br><span class="line">pair3: STL教程 http://c.biancheng.net/stl/</span><br><span class="line">pair4: C++教程 http://c.biancheng.net/cplus/</span><br><span class="line">pair5: Python教程 http://c.biancheng.net/python/</span><br><span class="line">new pair1: Java教程 http://c.biancheng.net/java/</span><br><span class="line">pair4: C++教程 http://c.biancheng.net/cplus/</span><br></pre></td></tr></table></figure>

<p>utility头文件中除了提供创建 pair 对象的方法之外，还为 pair 对象重载了 &lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;、&#x3D;&#x3D;、!&#x3D; 这 6 的运算符，其运算规则是：对于进行比较的 2 个 pair 对象，先比较 pair.first 元素的大小，如果相等则继续比较 pair.second 元素的大小。</p>
<p>Pair类的比较：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;utility&gt;      // pair</span><br><span class="line">#include &lt;string&gt;       // string</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    pair &lt;string, int&gt; pair1(&quot;STL教程&quot;, 20);</span><br><span class="line">    pair &lt;string, int&gt; pair2(&quot;C++教程&quot;, 20);</span><br><span class="line">    pair &lt;string, int&gt; pair3(&quot;C++教程&quot;, 30);</span><br><span class="line">    //pair1和pair2的key不同，value相同</span><br><span class="line">    if (pair1 != pair2) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;pair != pair2&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //pair2和pair3的key相同，value不同</span><br><span class="line">    if (pair2 != pair3) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;pair2 != pair3&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pair != pair2</span><br><span class="line">pair2 != pair3</span><br></pre></td></tr></table></figure>

<p>pair类模板还提供有一个 swap() 成员函数，能够互换 2 个 pair 对象的键值对，其操作成功的前提是这 2 个 pair 对象的键和值的类型要相同。</p>
<hr>
<p><font size="6"><strong>Map</strong></font></p>
<p>头文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br></pre></td></tr></table></figure>

<p>构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map&lt;T, T&gt; myMap;</span><br><span class="line">map&lt;string, int&gt; myMap&#123; &#123;&quot;C&quot;,10&#125;,&#123;&quot;STL&quot;,20&#125; &#125;;</span><br><span class="line">map&lt;string, int&gt;newMap(myMap);//直接复制过去</span><br><span class="line">map&lt;string, int, greater&lt;string&gt; &gt;myMap&#123; &#123;&quot;C&quot;,10&#125;,&#123;&quot;STL&quot;,20&#125; &#125;;//对键值做降序排序，STL在C前面</span><br></pre></td></tr></table></figure>

<p>数据存取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lower_bound(key);//返回第一个大于或等于 key 的键值对的双向迭代器</span><br><span class="line">upper_bound(key);//返回第一个大于 key 的键值对的迭代器</span><br><span class="line">myMap[n]=n;//直接使用operator访问</span><br><span class="line">at(key);//找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常</span><br><span class="line">insert();//向 map 容器中插入键值对</span><br><span class="line">erase();//删除 map 容器指定位置、指定键值或者指定区域内的键值对</span><br><span class="line">swap();//交换 2 个 map 容器中存储的键值对</span><br><span class="line">clear();//清空 map 容器中所有的键值对</span><br></pre></td></tr></table></figure>

<p>大小操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">empty();//判断map是否为空 </span><br><span class="line">size();//返回当前 map 容器中存有键值对的个数。</span><br><span class="line">max_size();//返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</span><br><span class="line">count(key);//查找键为 key 的键值对的个数并返回（由于key唯一故最大值为1）</span><br></pre></td></tr></table></figure>

<p><font size="5"><strong>Multimap</strong></font></p>
<p>和 map 容器的区别在于，multimap 容器中可以同时存储多（≥2）个键相同的键值对。</p>
<p>构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">multimap&lt;string, string&gt; mymultimap;</span><br></pre></td></tr></table></figure>

<p><font size="5"><strong>Unordered_Map &#x2F; Unordered_Multimap</strong></font></p>
<p>map内部实现了一个红黑树，而unordered_map内部实现了一个哈希表。因此效率后者大于前者，内存占有率前者大于后者。</p>
<p>头文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;unordered_multimap&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p><font size="6"><strong>Set</strong></font></p>
<p>头文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;set&gt;</span><br></pre></td></tr></table></figure>

<p>构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set&lt;T&gt; myset;</span><br><span class="line">set&lt;string,greater&lt;string&gt; &gt; myset;//降序set容器</span><br></pre></td></tr></table></figure>

<p>数据存取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lower_bound(val);//返回第一个大于或等于 val 的元素的双向迭代器</span><br><span class="line">upper_bound(val);//返回第一个大于 val 的元素的迭代器</span><br><span class="line">insert();//向 set 容器中插入元素</span><br><span class="line">erase();//删除 set 容器中存储的元素</span><br><span class="line">swap();//交换 2 个 set 容器中存储的所有元素</span><br><span class="line">clear();//清空 set 容器中所有的元素</span><br><span class="line">find(val);//在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器</span><br></pre></td></tr></table></figure>

<p>大小操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">empty();//判断set是否为空 </span><br><span class="line">size();//返回当前 set 容器中存有元素的个数。</span><br><span class="line">max_size();//返回 set 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。</span><br><span class="line">count(val);//查找键为 val 的键值对的个数并返回（由于val唯一故最大值为1）</span><br></pre></td></tr></table></figure>

<p><font size="5"><strong>Multiset</strong></font></p>
<p>和 set 容器不同的是，multiset 容器可以存储多个值相同的元素。</p>
<p>构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">multiset&lt;string&gt; mymultiset;</span><br></pre></td></tr></table></figure>

<p><font size="5"><strong>Unordered_Set &#x2F; Unordered_Multiset</strong></font></p>
<p>与map和unordered_map同理。</p>
<p>头文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">#include &lt;unordered_multiset&gt;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<p><a id="4"><font size="6"><strong>④STL迭代器</strong></font></a></p>
<p>哪些容器支持迭代器：</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>迭代器类型</th>
</tr>
</thead>
<tbody><tr>
<td>array</td>
<td>随机访问</td>
</tr>
<tr>
<td>vector</td>
<td>随机访问</td>
</tr>
<tr>
<td>deque</td>
<td>随机访问</td>
</tr>
<tr>
<td>list</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>set &#x2F; multiset</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>map &#x2F; multimap</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>forward_list</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>unordered_map &#x2F; unordered_multimap</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>unordered_set &#x2F; unordered_multiset</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>stack</td>
<td>不支持迭代器</td>
</tr>
<tr>
<td>queue</td>
<td>不支持迭代器</td>
</tr>
</tbody></table>
<p>迭代器使用例（遍历Vector）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//遍历 vector 容器。</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">//需要引入 vector 头文件</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; v&#123;1,2,3,4,5,6,7,8,9,10&#125;; //v被初始化成有10个元素</span><br><span class="line">    cout &lt;&lt; &quot;第一种遍历方法：&quot; &lt;&lt; endl;</span><br><span class="line">    //size返回元素个数</span><br><span class="line">    for (int i = 0; i &lt; v.size(); ++i)</span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt;&quot; &quot;; //像普通数组一样使用vector容器</span><br><span class="line">    //创建一个正向迭代器，当然，vector也支持其他 3 种定义迭代器的方式</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; &quot;第二种遍历方法：&quot; &lt;&lt; endl;</span><br><span class="line">    vector&lt;int&gt;::iterator i;</span><br><span class="line">    //用 != 比较两个迭代器</span><br><span class="line">    for (i = v.begin(); i != v.end(); ++i)</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; &quot; &quot;;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; &quot;第三种遍历方法：&quot; &lt;&lt; endl;</span><br><span class="line">    for (i = v.begin(); i &lt; v.end(); ++i) //用 &lt; 比较两个迭代器</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; &quot; &quot;;</span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; &quot;第四种遍历方法：&quot; &lt;&lt; endl;</span><br><span class="line">    i = v.begin();</span><br><span class="line">    while (i &lt; v.end()) &#123; //间隔一个输出</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; &quot; &quot;;</span><br><span class="line">        i += 2; // 随机访问迭代器支持 &quot;+= 整数&quot;  的操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一种遍历方法：</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">第二种遍历方法：</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">第三种遍历方法：</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">第四种遍历方法：</span><br><span class="line">1 3 5 7 9</span><br></pre></td></tr></table></figure>

<hr>
<p><font size="6"><strong>总结</strong></font></p>
<p>这下总算是把各种花里胡哨的STL容器给理清楚了捏。其实写这篇博客也是为了方便自己查找各种方法和函数，能让自己在写题的时候快速取回记忆orz不得不说这些容器真的好用，少走了很多弯路！<br>最后希望自己以后能快速准确地让每道需要用到STL容器的题目和最合适使用在这道题上的STL容器喜结连理。（不是）</p>
<p><font size="4"><strong>——END——</strong></font></p>
]]></content>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
</search>
