<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World!</title>
    <url>/2023/01/31/Hello%20World!/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>建了个博客，捣鼓了一晚上。结果没想到是主题设置了一晚上。<br>家里网络实在是太慢了啦！！！！Orz<br>这篇文章也拿来试试看。</p>
]]></content>
      <tags>
        <tag>Chat</tag>
      </tags>
  </entry>
  <entry>
    <title>学习一下markdown语法吧</title>
    <url>/2023/02/01/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8Bmarkdown%E8%AF%AD%E6%B3%95%E5%90%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>“#”号测试：<br>#这句话好大<br>##这句话第二大<br>###这句话第三大<br>####这句话第四大<br>#####再大下去就没完了<br>######反正只要在前面加#号就是加粗变大罢<br>#######哇哦7个#号竟然没用了</p>
<hr>
<p>“*”号测试：<br>这是一句前面什么都没有加的文字<br><em>这是一句变成了斜体的文字</em><br><strong>这是一句变成了粗体的文字</strong><br><em><strong>三个星号竟然是粗体+斜体！</strong></em></p>
<hr>
<p>“-“号测试：</p>
<ul>
<li>列表是什么</li>
<li>前面加个-号出现了一个圆点变成了列表<ul>
<li>甚至还有第二级列表<ul>
<li>竟然还有第三级列表<ul>
<li>好像可以无穷无尽</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>数字加点测试：</p>
<ol>
<li>有序列表</li>
<li>他自动帮我换了序号。好帅！<ol>
<li>二级开始了新的排序</li>
</ol>
</li>
</ol>
<hr>
<p>图片测试：<br><img src="/images/favicon.png" alt="大可罢格的Logo"><br><em>大可罢格的Logo</em></p>
<p><img src="http://p1.music.126.net/mvFeIRSFgPrbxchU5BUtAQ==/109951168195571858.jpg" alt="可爱的芙兰老婆抱着小熊玩偶发呆"><br><em>可爱的芙兰老婆抱着小熊玩偶发呆</em></p>
<hr>
<p>加三个”&#96;”号能创建代码块耶</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cout&lt;&lt;&quot;Hello World!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>加”&gt;”竟然能引用一句话！</p>
<blockquote>
<p>叔叔云：“你所热爱的，就是你的生活。”</p>
<blockquote>
<p>蒙古上单云：“祝你身体健康”</p>
</blockquote>
</blockquote>
<hr>
<p>加”|”竟然是表格！？！</p>
<table>
<thead>
<tr>
<th>fl.</th>
<th>jrrp</th>
<th>qd</th>
</tr>
</thead>
<tbody><tr>
<td>星光</td>
<td>114514</td>
<td>520</td>
</tr>
<tr>
<td>芙兰</td>
<td>1919810</td>
<td>520</td>
</tr>
</tbody></table>
<hr>
<p>连续两个回车竟然才是换行</p>
<p>换行了吗</p>
<p>换行了吗</p>
<p>好像换了罢.jpg<br><font color="#0099ff">能换颜色诶！(#0099ff)<br><font color="blue">这个是蓝色(blue)<br><strong><font color="blue">这个是很粗的蓝色(blue)</font></strong></font></font></p>
<font color="black">
为了方便以后写东西，给自己整点颜色看看（划去）

<p><img src="/images/fontcolor.png" alt="大可罢格的Logo"></p>
<hr>
<p>这里能放音乐吗</p>
<!-- 简单示例 (id, server, type)  -->

    <div id="aplayer-FEZdaHLW" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1996926039" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>

<!-- 进阶示例 -->

    <div id="aplayer-QHcUtdUu" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="157288442" data-server="netease" data-type="album" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"></div>
<p>好像失败了……</p>
<hr>
<p>这里能放视频吗！</p>
<iframe src="https://player.bilibili.com/player.html?aid=474503881&page=11&as_wide=1&high_quality=1&danmaku=1" style="width: 62em; height: 35em;" allowfullscreen="allowfullscreen" width="100%" height="100%" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe></font>]]></content>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>番茄炒蛋bot(FLbot)帮助文档v0.77</title>
    <url>/2023/02/04/FLbot-HelpDoc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><font size="6"><strong>目录</strong></font></p>
<ol>
<li><a href="#1">番茄炒蛋bot简介</a></li>
<li><a href="#2">查询类指令</a></li>
<li><a href="#3">功能类指令</a></li>
<li><a href="#4">行动类指令</a></li>
<li><a href="#5">更新日志</a></li>
</ol>
<hr>
<p><a id="1"><font color="black" size="5"><strong>番茄炒蛋bot简介</strong></font></a></p>
<p>欢迎您使用番茄炒蛋bot（FLbot）！该bot是基于go-cqhttp，使用Python语言开发的一款娱乐型群聊机器人，并于2022年11月27日开始开发并投入到个人群聊中使用。欢迎加入个人群719317473一起交流。</p>
<p>部分效果截图：</p>
<p><img src="http://ys-f.ysepan.com/544024507/713425364/mgcvnyr88344H61GQNK2e/FLbot_1.JPG" alt="签到功能"><br><em>签到功能</em></p>
<p><img src="http://ys-f.ysepan.com/544024508/713425366/m76263J22KPLTmgcvny2b/FLbot_3.JPG" alt="五子棋功能"><br><em>五子棋功能</em></p>
<p><img src="http://ys-f.ysepan.com/544024508/713425367/m76263J22KPU2mgcvny57/FLbot_4.JPG" alt="弹奏功能"><br><em>弹奏功能</em></p>
<p><img src="http://ys-f.ysepan.com/544024508/713425368/m76263J22KPU3mgcvny09/FLbot_5.JPG" alt="商店功能"><br><em>商店功能</em></p>
<p><img src="http://ys-f.ysepan.com/544024509/713425370/mgcvnyu55455F36JNT7cd/FLbot_7.JPG" alt="查涩图功能"><br><em>查涩图功能</em></p>
<p>Bot源码：<a href="https://github.com/Star11ght/FLbot">https://github.com/Star11ght/FLbot</a></p>
<p>额外提示：[]符号表示输入限定的内容，实际使用fl时无需额外添加</p>
<hr>
<p><a id="2"><font color="black" size="5"><strong>查询类指令</strong></font></a></p>
<p><font color="black" size="4"><strong>fl.qd</strong></font></p>
<ul>
<li>签到功能，每日刷新，可领积分。</li>
<li>签到积分机制(fl.qdhelp)：<ul>
<li>获得的积分与今日最高人品(jrrp)，好感度(favor)与连续签到天数(ren)有关</li>
<li>随机获得积分x，(8 + jrrp &#x2F; 250) ≤ x ≤ 50</li>
<li>再计算额外奖励率y，favor &#x2F; 10 ≤ y ≤ (ren - 1) &#x2F; 50，若左边界大于右边界则两边界互换</li>
<li>最后得出今日获得的积分为 x(1+y)</li>
<li>若银行账户内有存款，将会支付给您1％<del>3％的利息（存款大于10000时为1％</del>2％）。</li>
</ul>
</li>
<li>小技巧1：如果身上rp重置卡数量充足且jrrp不高，可使用重置卡提高x的取值再签到</li>
<li>小技巧2：可以在每天签到之前将所有的积分存到银行里获取最多的积分<del>也可以在签到之前玩几百局1A2B猜数字</del></li>
<li>若断签可使用补签卡(fl.use 1)</li>
</ul>
<p><font color="black" size="4"><strong>fl.jrrp</strong></font></p>
<ul>
<li>查询今日人品功能，每日刷新</li>
<li>达到一定值可进入今日人品最高&#x2F;最低排行榜(fl.rank 2&#x2F;fl.rank 4)</li>
<li>可使用rp重置卡提高人品(fl.use 2)，也有可能不变</li>
</ul>
<p><font color="black" size="4"><strong>fl.rank [数字]</strong></font></p>
<ul>
<li>查询各种各样的排名<ul>
<li>fl.rank 1：今日人品排名</li>
<li>fl.rank 2：今日人品历史最高排名</li>
<li>fl.rank 3：现持有积分总排名</li>
<li>fl.rank 4：今日人品历史最低排名</li>
</ul>
</li>
</ul>
<p><font color="black" size="4"><strong>fl.db&#x2F;fl.darkbug</strong></font></p>
<ul>
<li>随机分享MiyakTik的音乐</li>
<li><del>你MiyakTik的音乐和我DarkBug有什么关系</del></li>
</ul>
<p><font color="black" size="4"><strong>fl.me</strong></font></p>
<ul>
<li>可查询自己的个人信息</li>
<li>包含：昵称，好感度，积分，连续签到天数，最高人品</li>
<li><del>favor达到一定值有额外对话</del></li>
</ul>
<p><font color="black" size="4"><strong>fl.help</strong></font></p>
<ul>
<li><del>我觉得你来看这个文档的目的肯定不是来看这一条的</del></li>
</ul>
<hr>
<p><a id="3"><font color="black" size="5"><strong>功能类指令</strong></font></a></p>
<p><font color="black" size="4"><strong>fl.chess [数字(房间号)]</strong></font></p>
<ul>
<li>输入数字即可创建五子棋房间</li>
<li>输入和别人相同的数字即可加入别人的五子棋局</li>
<li>在两个不同群聊间输入同一数字也可跨群对局<del>就是看不到对方下在哪(虚 空 索 敌)</del></li>
<li>棋盘坐标：先字母后数字</li>
</ul>
<p><font color="black" size="4"><strong>fl.tap</strong></font></p>
<ul>
<li>让芙兰戳戳你。真不戳！</li>
</ul>
<p><font color="black" size="4"><strong>fl.game [数字]</strong></font></p>
<ul>
<li>玩各种各样的游戏。目前各种各样&#x3D;2。<ul>
<li>fl.game 1：1A2B猜数字(游戏规则:fl.game 114514)，成功可获得积分</li>
<li>fl.game 2：寻找炸弹人偶，多人游戏胜利可获得积分</li>
</ul>
</li>
</ul>
<p><font color="black" size="4"><strong>fl.piano [音符串]</strong></font></p>
<ul>
<li>让芙兰用钢琴为你弹奏一段旋律。</li>
<li>音符串格式要求（从左到右）：<ul>
<li>（可选）左括号”(“降一个八度，右括号”)”反之，默认为小字一组，最多可使用三个括号</li>
<li>（必选）输入音符0~7，可用合法的升降号#或b，0为空拍无升降号</li>
<li>（可选）加号”+”速度加快一倍，减号”-“速度放慢一倍，默认下为8分音符，范围为全音符~32分音符</li>
<li>如致爱丽丝：fl.piano 33b33b3(721(6-</li>
</ul>
</li>
</ul>
<p><font color="black" size="4"><strong>fl.tune</strong></font></p>
<ul>
<li>与芙兰玩猜音游戏，范围A1~C9，成功可获得5积分</li>
</ul>
<p><font color="black" size="4"><strong>fl.d[骰子面数]</strong></font></p>
<ul>
<li>随机获得n面骰点数(n≥1)</li>
<li><del>实际上是n+1面骰，得出的点数结果中包括0点，扔莫比乌斯环有啥意义吗.jpg</del></li>
</ul>
<p><font color="black" size="4"><strong>fl.pic [数字][图片]</strong></font></p>
<ul>
<li>将图片进行各种各样的翻转。这里的各种各样&#x3D;5。<ul>
<li>fl.pic 1[图片]：水平翻转图片左半边拼在右半边</li>
<li>fl.pic 2[图片]：水平翻转图片右半边拼在左半边</li>
<li>fl.pic 3[图片]：垂直翻转图片上半边拼在下半边</li>
<li>fl.pic 4[图片]：垂直翻转图片下半边拼在上半边</li>
<li>fl.pic 5[图片]：翻转图片颜色</li>
</ul>
</li>
</ul>
<p><font color="black" size="4"><strong>fl.picture [(可选)tag]，[(可选)tag]，……</strong></font></p>
<ul>
<li>查找涩图功能，引用了神代綺凛大佬的API接口，地址：<a href="https://api.lolicon.app/#/setu">https://api.lolicon.app/#/setu</a></li>
<li>不加tag为随机出图，加tag根据tag搜索指定图片，多个tag间用中文逗号隔开</li>
<li><del>保留了R-18功能但是我不说怎么触发还是保群要紧.jpg</del></li>
</ul>
<p><font color="black" size="4"><strong>fl.read [字符串]</strong></font></p>
<ul>
<li>让芙兰用语音复述你发的字符串，简单粗暴</li>
</ul>
<p><font color="black" size="4"><strong>fl.repeat [字符串]</strong></font></p>
<ul>
<li>让芙兰重复你发的字符串，简单粗暴</li>
<li><del>请不要尝试与星光相关的字符串，这改变不了他tljl的事实</del></li>
</ul>
<p><font color="black" size="4"><strong>fl.news</strong></font></p>
<ul>
<li>获取今日的60秒新闻图片，大约每天凌晨两点更新</li>
<li>每天八点整fl也会在群里自动发送图片</li>
</ul>
<p><font color="black" size="4"><strong>fl.head [(可选)QQ号]</strong></font></p>
<ul>
<li>获取该QQ账号的头像</li>
<li>若不输入QQ号则将获取自己的头像</li>
</ul>
<p><font color="black" size="4"><strong>fl.days [YYYY-MM-DD] [事件名称]</strong></font></p>
<ul>
<li>设定倒数日事件，日期格式为四位年份数-两位月份数-两位天数，如2020年1月1日即为2020-01-01</li>
<li>每天凌晨12点芙兰会在主群(719317473)发送所有已设定的倒数日事件的剩余天数</li>
<li>发送fl.days del可删除自己的倒数日事件</li>
</ul>
<p><font color="black" size="4"><strong>fl.ai&#x2F;ai2&#x2F;aitalk [聊天内容]</strong></font></p>
<ul>
<li>与AI聊天机器人对话，ai和ai2为两个不同的机器人</li>
<li>aitalk可让两个机器人互相对话</li>
</ul>
<hr>
<p><a id="4"><font color="black" size="5"><strong>行动类指令</strong></font></a></p>
<p><font color="black" size="4"><strong>fl.name [名字]</strong></font></p>
<ul>
<li>添加自己的称谓，让芙兰以后这么叫你</li>
<li><del>想取名老公就取名老公吧，口亨！我才不会吃醋</del></li>
</ul>
<p><font color="black" size="4"><strong>fl.bank</strong></font></p>
<ul>
<li>使用幻想乡交通银行储蓄功能</li>
<li>有利息，需通过签到获得利息</li>
<li>fl.bank 1 [积分数]：将积分存进银行</li>
<li>fl.bank 2 [积分数]：从银行中取出积分</li>
</ul>
<p><font color="black" size="4"><strong>fl.borrow [QQ号] [积分数]</strong></font></p>
<ul>
<li>将银行卡内的指定积分汇款至别的账号的银行储蓄当中</li>
<li>汇款的账号需至少触发过一次fl.bank功能</li>
</ul>
<p><font color="black" size="4"><strong>fl.favorup</strong></font></p>
<ul>
<li>提升与芙兰的好感度，需花费积分</li>
<li>所需积分(point)与好感度(favor)的关系：point &#x3D; favor × 50</li>
</ul>
<p><font color="black" size="4"><strong>fl.raffle</strong></font></p>
<ul>
<li>花费50积分进行一次抽奖，每天首次抽奖免费，中奖概率50%<ul>
<li>特等奖(1%)：获得500积分</li>
<li>一等奖(4%)：获得200积分</li>
<li>二等奖(10%)：获得100积分</li>
<li>三等奖(15%)：获得50积分</li>
<li>鼓励奖(20%)：获得30积分</li>
</ul>
</li>
</ul>
<p><font color="black" size="4"><strong>fl.store [物品序号]</strong></font></p>
<ul>
<li>前往商店购买物品</li>
<li>输入物品序号即可购买，部分物品需要达到一定好感度才能购买</li>
</ul>
<p><font color="black" size="4"><strong>fl.bag</strong></font></p>
<ul>
<li>查询自己背包内有哪些物品，并标出物品序号</li>
</ul>
<p><font color="black" size="4"><strong>fl.use [物品序号]</strong></font></p>
<ul>
<li>可以使用背包内的物品</li>
<li>使用效果与当前所处位置有关，不同位置可能有不同效果</li>
<li>部分剧情通过使用物品推进</li>
</ul>
<p><font color="black" size="4"><strong>fl.place</strong></font></p>
<ul>
<li>可查询自己当前所处的位置，显示地点序号</li>
</ul>
<p><font color="black" size="4"><strong>fl.move [地点序号]</strong></font></p>
<ul>
<li>前往不同的地点</li>
<li>部分地点每日首次前往会触发随机奖励或事件</li>
<li>部分剧情可通过前往地点推进</li>
</ul>
<hr>
<p><a id="5"><font color="black" size="5"><strong>更新日志</strong></font></a></p>
<p><font color="black" size="4"><strong>Version 1.00 (2023&#x2F;04&#x2F;01)</strong></font></p>
<ul>
<li>将FL迁移至阿里云服务器，修复了众多BUG</li>
<li>增加了fl.days（倒数日功能），修复了fl.read功能</li>
<li>修改了银行功能，存钱取钱需支付1.5%的服务费</li>
<li>优化了主函数代码</li>
</ul>
<p><font color="black" size="4"><strong>Version 0.77 (2023&#x2F;02&#x2F;17)</strong></font></p>
<ul>
<li>增加了news、head、ai功能</li>
<li>增加了凌晨12点倒数日和早上8点60秒新闻的功能</li>
</ul>
<p><font color="black" size="4"><strong>Version 0.66 (2023&#x2F;02&#x2F;06)</strong></font></p>
<ul>
<li>增加了fl.bank功能和fl.borrow功能</li>
<li>修复了积分小数点位数爆炸的bug</li>
<li>修复了jrrp最高记录刷新后无法使用积分相关功能的bug</li>
</ul>
<p><font color="black" size="4"><strong>Version 0.64 (2023&#x2F;02&#x2F;04)</strong></font></p>
<ul>
<li>增加了网页版帮助文档</li>
<li>修改了help功能的输出方式</li>
<li>增加了favorup、raffle、store、bag、use、place和move功能</li>
<li>增加了8个新道具和5(+2)个新地点，共10种move事件和44种use事件</li>
</ul>
<p>（最近一次更新于2023.04.01 21:27）</p>
]]></content>
      <tags>
        <tag>FLbot</tag>
      </tags>
  </entry>
  <entry>
    <title>番茄炒蛋bot(FLbot)道具使用攻略</title>
    <url>/2023/02/07/FLbot-MoveAndUse/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><font color="black" size="4"><strong>关于fl.move和fl.use的使用方法，请参见该文章：</strong></font><br><a href="https://star11ght.github.io/2023/02/04/FLbot-HelpDoc/">https://star11ght.github.io/2023/02/04/FLbot-HelpDoc/</a></p>
<p>关于表格：P为积分，favor为好感度，事件前的括号为触发概率，不带“且”字的不可与前者(或后者)同时触发</p>
<p><font color="black" size="4"><strong>① fl.move</strong></font></p>
<p>特殊事件：移动时有5%的概率会被帝绊倒并失去20P</p>
<table>
<thead>
<tr>
<th>fl.move</th>
<th>当日初次</th>
</tr>
</thead>
<tbody><tr>
<td>0 人间之里</td>
<td>无</td>
</tr>
<tr>
<td>1 雾之湖</td>
<td>(29.99%)+199.99P</td>
</tr>
<tr>
<td>2 红魔馆门口<br>(favor≥15)</td>
<td>无</td>
</tr>
<tr>
<td>2 红魔馆门口<br>(favor&lt;15)</td>
<td>(70%)美铃醒着<br>(30%)美铃睡着</td>
</tr>
<tr>
<td>2-1 红魔馆<br>(地下室)</td>
<td>(60-favor×2%)favor+1<br>(favor×2%)+100P</td>
</tr>
<tr>
<td>2-2 红魔馆<br>(图书馆)</td>
<td>无</td>
</tr>
<tr>
<td>2-3 红魔馆<br>(大堂中央)</td>
<td>无</td>
</tr>
<tr>
<td>2-4 红魔馆<br>(主殿堂)</td>
<td>(25%)favor&lt;20时favor+1，favor≥20时+250P<br>(25%)+50P</td>
</tr>
</tbody></table>
<p><font color="black" size="4"><strong>② fl.use</strong></font></p>
<p>横向为道具序号，纵向为使用地点。<br>序号为1(补签卡)和2(rp重置卡)的物品在任何地点下使用效果均相同。</p>
<p>序号3~5：</p>
<table>
<thead>
<tr>
<th>fl.use</th>
<th>3 ⑨转大肠</th>
<th>4 草莓蛋糕</th>
<th>5 红苹果</th>
</tr>
</thead>
<tbody><tr>
<td>0 人间之里</td>
<td>无</td>
<td>无</td>
<td>(75%)+150P</td>
</tr>
<tr>
<td>1 雾之湖</td>
<td>(50%)+199.99P</td>
<td>(50%)+199.99P</td>
<td>无</td>
</tr>
<tr>
<td>2 红魔馆门口<br>(醒着的美铃)</td>
<td>(favor&lt;15)让美铃睡着</td>
<td>不消耗</td>
<td>不消耗</td>
</tr>
<tr>
<td>2-0 红魔馆门口<br>(睡着的美铃)</td>
<td>让美铃醒来<br>且+250P</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>2-1 红魔馆<br>(地下室)</td>
<td>-100P</td>
<td>+150P</td>
<td>(50-favor×2%)favor+1<br>(favor≥25时10%)+500P</td>
</tr>
<tr>
<td>2-2 红魔馆<br>(图书馆)</td>
<td>其它随机食物</td>
<td>无</td>
<td>不消耗</td>
</tr>
<tr>
<td>2-3 红魔馆<br>(大堂中央)</td>
<td>不消耗<br>且被送回门口</td>
<td>(75%)+123P<br>(25%)被送回门口</td>
<td>+111P</td>
</tr>
<tr>
<td>2-4 红魔馆<br>(主殿堂)</td>
<td>不消耗<br>且被送回门口</td>
<td>(50%)+222P</td>
<td>(40-favor×2%)favor+1<br>(favor≥20时25%)+150P<br>均不符合条件+50P</td>
</tr>
</tbody></table>
<p>序号6~8：</p>
<table>
<thead>
<tr>
<th>fl.use</th>
<th>6 红茶玛奇朵</th>
<th>7 冰糖雪糕</th>
<th>8 黑松露炒饭</th>
</tr>
</thead>
<tbody><tr>
<td>0 人间之里</td>
<td>无</td>
<td>无</td>
<td>+200P</td>
</tr>
<tr>
<td>1 雾之湖</td>
<td>无</td>
<td>+149.99P</td>
<td>+199.99P</td>
</tr>
<tr>
<td>2 红魔馆门口<br>(醒着的美铃)</td>
<td>让美铃睡着</td>
<td>不消耗</td>
<td>不消耗</td>
</tr>
<tr>
<td>2-0 红魔馆门口<br>(睡着的美铃)</td>
<td>无</td>
<td>(40%)+250P</td>
<td>(50%)+300P</td>
</tr>
<tr>
<td>2-1 红魔馆<br>(地下室)</td>
<td>+50P且<br>(30-favor×2%)favor+1<br>(favor≥15时2%)favor+1</td>
<td>无</td>
<td>(60-favor×2%<br>或favor≥30时2%)favor+2<br>(favor×2%<br>或favor≥30时58%)+200P</td>
</tr>
<tr>
<td>2-2 红魔馆<br>(图书馆)</td>
<td>+100P</td>
<td>无</td>
<td>不消耗</td>
</tr>
<tr>
<td>2-3 红魔馆<br>(大堂中央)</td>
<td>(50%)+150P<br>(50%)+50P</td>
<td>不消耗</td>
<td>+220P</td>
</tr>
<tr>
<td>2-4 红魔馆<br>(主殿堂)</td>
<td>不消耗</td>
<td>(50%)+229.99P</td>
<td>不消耗</td>
</tr>
</tbody></table>
<p>序号9~11：</p>
<table>
<thead>
<tr>
<th>fl.use</th>
<th>9 琪露诺冰块</th>
<th>10 冰冻的鱼</th>
<th>11 草莓奶油</th>
</tr>
</thead>
<tbody><tr>
<td>0 人间之里</td>
<td>无</td>
<td>不消耗</td>
<td>无</td>
</tr>
<tr>
<td>1 雾之湖</td>
<td>无</td>
<td>+100P</td>
<td>+220P</td>
</tr>
<tr>
<td>2 红魔馆门口<br>(醒着的美铃)</td>
<td>不消耗</td>
<td>不消耗</td>
<td>不消耗</td>
</tr>
<tr>
<td>2-0 红魔馆门口<br>(睡着的美铃)</td>
<td>无</td>
<td>不消耗</td>
<td>让美铃醒来</td>
</tr>
<tr>
<td>2-1 红魔馆<br>(地下室)</td>
<td>无</td>
<td>不消耗</td>
<td>不消耗</td>
</tr>
<tr>
<td>2-2 红魔馆<br>(图书馆)</td>
<td>不消耗</td>
<td>无</td>
<td>+220P</td>
</tr>
<tr>
<td>2-3 红魔馆<br>(大堂中央)</td>
<td>+100P</td>
<td>(50%)+200P</td>
<td>(30%)+300P<br>(70%)+50P</td>
</tr>
<tr>
<td>2-4 红魔馆<br>(主殿堂)</td>
<td>无</td>
<td>不消耗</td>
<td>不消耗</td>
</tr>
</tbody></table>
<p>序号12~13，23：</p>
<table>
<thead>
<tr>
<th>fl.use</th>
<th>12 苹果草莓派</th>
<th>13 雾之矿泉水</th>
<th>23 木棍</th>
</tr>
</thead>
<tbody><tr>
<td>星光代码没写完……（偷懒中.jpg）</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>序号21：</p>
<table>
<thead>
<tr>
<th>fl.use</th>
<th>21 普通的鱼竿</th>
</tr>
</thead>
<tbody><tr>
<td>0 人间之里</td>
<td>无</td>
</tr>
<tr>
<td>1 雾之湖</td>
<td>(3.63%)rp重置卡<br>(10.91%)烧烤机或+150P<br>(45.4%)随机东方角色</td>
</tr>
<tr>
<td>2 红魔馆门口<br>(醒着的美铃)</td>
<td>无</td>
</tr>
<tr>
<td>2-0 红魔馆门口<br>(睡着的美铃)</td>
<td>无</td>
</tr>
<tr>
<td>2-1 红魔馆<br>(地下室)</td>
<td>无</td>
</tr>
<tr>
<td>2-2 红魔馆<br>(图书馆)</td>
<td>无</td>
</tr>
<tr>
<td>2-3 红魔馆<br>(大堂中央)</td>
<td>被送回门口</td>
</tr>
<tr>
<td>2-4 红魔馆<br>(主殿堂)</td>
<td>无</td>
</tr>
</tbody></table>
<p>序号22（只与使用物品有关，与地点无关）：</p>
<table>
<thead>
<tr>
<th>fl.use</th>
<th>22 烧烤机</th>
</tr>
</thead>
<tbody><tr>
<td>1 补签卡</td>
<td>(50%)变成rp重置卡</td>
</tr>
<tr>
<td>2 rp重置卡</td>
<td>(50%)变成补签卡</td>
</tr>
<tr>
<td>3 ⑨转大肠</td>
<td>不消耗</td>
</tr>
<tr>
<td>4 草莓蛋糕</td>
<td>变成草莓奶油</td>
</tr>
<tr>
<td>5 红苹果</td>
<td>(单独烤)无<br>(包内有草莓奶油)变成苹果草莓派</td>
</tr>
<tr>
<td>6 红茶玛奇朵</td>
<td>不消耗</td>
</tr>
<tr>
<td>7 冰糖雪糕</td>
<td>变成木棍</td>
</tr>
<tr>
<td>8 黑松露炒饭</td>
<td>不消耗</td>
</tr>
<tr>
<td>9 琪露诺冰块</td>
<td>变成雾之矿泉水</td>
</tr>
<tr>
<td>10 冰冻的鱼</td>
<td>+250P</td>
</tr>
<tr>
<td>11 草莓奶油</td>
<td>+50P</td>
</tr>
<tr>
<td>12 苹果草莓派</td>
<td>不消耗</td>
</tr>
<tr>
<td>13 雾之矿泉水</td>
<td>不消耗</td>
</tr>
<tr>
<td>21 普通的鱼竿</td>
<td>无</td>
</tr>
<tr>
<td>22 烧烤机</td>
<td>不消耗</td>
</tr>
<tr>
<td>23 木棍</td>
<td>无</td>
</tr>
</tbody></table>
<p>（最后更新于2023.04.01 22:00）</p>
]]></content>
      <tags>
        <tag>FLbot</tag>
      </tags>
  </entry>
  <entry>
    <title>2023年3月ACM校赛选拔赛复盘+心得</title>
    <url>/2023/03/12/202303ACM/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这次拿了第三，败在了时间上，有些可惜。（封面的123为自己的队伍）<br>一共10道题，A了BCDFH，BF拿下手刹，AJ卡在思路，EGI没动过。<br>接下来按照字母顺序复盘一下。</p>
<p><font size="6"><strong>目录</strong></font></p>
<p><strong><a href="#A">A. Message - From CodeForces 156A</a></strong><br><strong><a href="#B">B. Hometask - From CodeForces 214B</a></strong><br><strong><a href="#C">C. Trees in a Row - From CodeForces 402B</a></strong><br><strong><a href="#D">D. Flag - From CodeForces 16A</a></strong><br><strong><a href="#E">E. Smart Boy - From CodeForces 38F</a></strong><br><strong><a href="#F">F. Airport - From CodeForces 218B</a></strong><br><strong><a href="#G">G. Three Arrays - From CodeForces 392D</a></strong><br><strong><a href="#H">H. Sockets - From CodeForces 257A</a></strong><br><strong><a href="#I">I. Apple Tree - From CodeForces 349D</a></strong><br><strong><a href="#J">J. Game with Strings - From CodeForces 354B</a></strong></p>
<hr>
<p><a id="A"><font color="black" size="5"><strong>A. Message - From CodeForces 156A</strong></font></a></p>
<p>原题地址：<a href="https://codeforces.com/problemset/problem/156/A">https://codeforces.com/problemset/problem/156/A</a></p>
<p><img src="http://ys-f.ysepan.com/544024527/713499178/jhdwlvl88354U71G9PU481/20230309A1.png" alt="A题题面"><br><img src="http://ys-f.ysepan.com/544024527/713499179/jhdwlvl88354U71G9PU5d5/20230309A2.png" alt="A题样例"></p>
<p>题目大意是给两串字符串，求第二串字符串要经过几次变换才能成为第一串字符串的子串，变换方式可以是在末尾删去或增加字符，或者将其中任意一个字符变成其它字符。<br>负责这道题目的是ckt，码完后能对上样例和自己举的一些例子，最后交上去却只有55.5%，并未发现特例。于是在这道题上纠结了半天。<br>比赛结束后去网上搜了一下，找到一个更精简的贪心算法，也是将2串与1串进行1串的长度次比较，找到两个串之间字母能对应上的最大值，次数即为串长-最大值。</p>
<p>本题AC代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">string a,b;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    int len1=a.length();</span><br><span class="line">    int len2=b.length();</span><br><span class="line">    int ans=10000000;</span><br><span class="line">    int len=len2;</span><br><span class="line">    if(len1&lt;len2)//将长度更大的字符串放在前面</span><br><span class="line">    &#123;</span><br><span class="line">        swap(a,b);</span><br><span class="line">        swap(len1,len2);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;len2;i++)//将2串作为基准串，1串与2串进行对比</span><br><span class="line">    &#123;</span><br><span class="line">        int num=0;</span><br><span class="line">        for(int k=i,j=0;k&lt;len2&amp;&amp;j&lt;len1;k++,j++)</span><br><span class="line">        &#123;</span><br><span class="line">           if(b[k]==a[j])</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=min(ans,len-num);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;len1;i++)//将1串作为基准串，2串与1串进行对比</span><br><span class="line">    &#123;</span><br><span class="line">        int num=0;</span><br><span class="line">        for(int k=i,j=0;j&lt;len2&amp;&amp;k&lt;len1;j++,k++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[k]==b[j])</span><br><span class="line">                num++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=min(ans,len-num);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这道题在场的各位竟然都没A出来。估计都紧张了吧（笑）</p>
<hr>
<p><a id="B"><font color="black" size="5"><strong>B. Hometask - From CodeForces 214B</strong></font></a></p>
<p>原题地址：<a href="https://codeforces.com/problemset/problem/214/B">https://codeforces.com/problemset/problem/214/B</a></p>
<p><img src="http://ys-f.ysepan.com/544024538/713499243/o76273W337WNH6lgfsmzee/20230309B1.png" alt="B题题面"><br><img src="http://ys-f.ysepan.com/544024539/713499244/lgfsmzo55465S476UMJ62d/20230309B2.png" alt="B题样例"></p>
<p>AC的第一道题，时间充裕心态良好，拿了个手刹，难度不高。<br>题意是给定n个数字，取出这堆数字中的部分数字或所有数字，并将其拼成能被2，3，5整除的数，求这个数最大是多少。<br>这道题主打的也是个贪心算法。先判断能否被2，3，5整除，思路是拆成10和3，这就意味着凑成这组数需要满足两个条件，即结尾必须是0及所有数的总和能被3整除。若能整除则从大到小一个个输出（输入时用了桶排序计算个数）；若不能，先判断这组数中是否存在“余数+3的整数倍”的数，从小到大查找，若存在除去这个数即可；若不存在“余数+3的整数倍”的数，还可以判断“3-余数+3的整数倍”的数是否大于等于2，除去这两个数即可。若以上都不满足输出-1。</p>
<p>因为是比赛，所以未能简化代码，变量名也瞎取。看个乐就行。</p>
<p>本题AC代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long number[10]=&#123;0&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    long long n,sub=0;</span><br><span class="line">    int x[100005],i;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x[i];</span><br><span class="line">        number[x[i]]++;</span><br><span class="line">        sub = sub + x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    if(number[0]==0)&#123;</span><br><span class="line">        cout&lt;&lt;-1;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(number[0]==n)&#123;</span><br><span class="line">        cout&lt;&lt;0;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int div = sub%3,x1=n,r=0;</span><br><span class="line">    if(div!=0)&#123;</span><br><span class="line">        for(i=0;i&lt;=2;i++)&#123;</span><br><span class="line">            if(number[div+i*3]!=0)break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i==3)&#123;</span><br><span class="line">            if(div==1)&#123;</span><br><span class="line">                for(i=0;i&lt;=2;i++)&#123;</span><br><span class="line">                    while(number[2+i*3]!=0)&#123;</span><br><span class="line">                        r++;</span><br><span class="line">                        number[2+i*3]--;</span><br><span class="line">                        if(r==2)break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(r==2)break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(div==2)&#123;</span><br><span class="line">                for(i=0;i&lt;=2;i++)&#123;</span><br><span class="line">                    while(number[1+i*3]!=0)&#123;</span><br><span class="line">                        r++;</span><br><span class="line">                        number[1+i*3]--;</span><br><span class="line">                        if(r==2)break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(r==2)break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(r!=2)&#123;</span><br><span class="line">                cout&lt;&lt;-1;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            x1=n-2;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            number[div+i*3]--;</span><br><span class="line">            x1=n-1;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    if(number[0]==x1)&#123;</span><br><span class="line">        cout&lt;&lt;0;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=9;i&gt;=0;i--)&#123;</span><br><span class="line">        for(int j=1;j&lt;=number[i];j++)&#123;</span><br><span class="line">            cout&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**************************************************************</span><br><span class="line">    Problem: 3518</span><br><span class="line">    User: 123 [URright]</span><br><span class="line">    Language: C++</span><br><span class="line">    Result: 正确</span><br><span class="line">    Time:13 ms</span><br><span class="line">    Memory:2444 kb</span><br><span class="line">****************************************************************/</span><br></pre></td></tr></table></figure>

<hr>
<p><a id="C"><font color="black" size="5"><strong>C. Trees in a Row - From CodeForces 402B</strong></font></a></p>
<p>原题地址：<a href="https://codeforces.com/problemset/problem/402/B">https://codeforces.com/problemset/problem/402/B</a></p>
<p><img src="http://ys-d.ysepan.com/544024529/713499309/jhdwlvm55465S47JJMMKe1/20230309C1.png" alt="C题题面"><br><img src="http://ys-d.ysepan.com/544024529/713499310/jhdwlvm55465S47JJMMLb7/20230309C2.png" alt="C题样例"></p>
<p>和ckt一起写的代码，他用他的思路我用我的思路写。<br>也是很简单的一题。输入n个数，要求这n个数成等差数列，k为公差，求最少的更改次数，并输出更改过程。<br>思路也很简单，找到符合要求的数最多的一组，然后改剩下不符合的即可。<br>由于不清楚是否要求升序输出，于是多写了一段让其升序输出的代码。</p>
<p>本题AC代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int num[1005],fuhao[1005],in[1005],minuss[1005];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k,maxn=0,left,right,tn=0,tl=0,tr;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;num[i];</span><br><span class="line">        if(i&gt;=2)&#123;</span><br><span class="line">            if(num[i]-num[i-1]==k)&#123;</span><br><span class="line">                if(i-tl+1!=tn)&#123;</span><br><span class="line">                    tl=i-1;</span><br><span class="line">                    tn=2;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    tn++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(tn&gt;maxn)&#123;</span><br><span class="line">                tr=i-1;</span><br><span class="line">                maxn=tn;</span><br><span class="line">                left=tl;</span><br><span class="line">                right=tr;</span><br><span class="line">                tn=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(maxn==0)&#123;</span><br><span class="line">        left=1;</span><br><span class="line">        right=1;</span><br><span class="line">    &#125;</span><br><span class="line">    int minusa,minusb,total=0;</span><br><span class="line">    for(int i=left-1;i&gt;=1;i--)&#123;</span><br><span class="line">        minusa = num[i+1] - k;//yuanbendezhi</span><br><span class="line">        minusb = minusa - num[i];//chazhi</span><br><span class="line">        num[i] = minusa;</span><br><span class="line">        if(minusb &gt; 0)&#123;</span><br><span class="line">            total++;</span><br><span class="line">            fuhao[total] = 1;</span><br><span class="line">            in[total]=i;</span><br><span class="line">            minuss[total]=minusb;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(minusb&lt;0)&#123;</span><br><span class="line">            total++;</span><br><span class="line">            fuhao[total] = -1;</span><br><span class="line">            in[total]=i;</span><br><span class="line">            minuss[total]=-minusb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int red = total;</span><br><span class="line">    for(int i=right+1;i&lt;=n;i++)&#123;</span><br><span class="line">        minusa = num[i-1] + k;//yuanbendezhi</span><br><span class="line">        minusb = minusa - num[i];//chazhi</span><br><span class="line">        num[i] = minusa;</span><br><span class="line">        if(minusb &gt; 0)&#123;</span><br><span class="line">            total++;</span><br><span class="line">            fuhao[total] = 1;</span><br><span class="line">            in[total]=i;</span><br><span class="line">            minuss[total]=minusb;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(minusb&lt;0)&#123;</span><br><span class="line">            total++;</span><br><span class="line">            fuhao[total] = -1;</span><br><span class="line">            in[total]=i;</span><br><span class="line">            minuss[total]=-minusb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;total&lt;&lt;endl;</span><br><span class="line">    for(int i=red;i&gt;=1;i--)&#123;</span><br><span class="line">        if(fuhao[i]==1)cout&lt;&lt;&quot;+ &quot;;</span><br><span class="line">        else cout&lt;&lt;&quot;- &quot;;</span><br><span class="line">        cout&lt;&lt;in[i]&lt;&lt;&quot; &quot;&lt;&lt;minuss[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=red+1;i&lt;=total;i++)&#123;</span><br><span class="line">        if(fuhao[i]==1)cout&lt;&lt;&quot;+ &quot;;</span><br><span class="line">        else cout&lt;&lt;&quot;- &quot;;</span><br><span class="line">        cout&lt;&lt;in[i]&lt;&lt;&quot; &quot;&lt;&lt;minuss[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**************************************************************</span><br><span class="line">    Problem: 2889</span><br><span class="line">    User: 123 [URright]</span><br><span class="line">    Language: C++</span><br><span class="line">    Result: 正确</span><br><span class="line">    Time:14 ms</span><br><span class="line">    Memory:2192 kb</span><br><span class="line">****************************************************************/</span><br></pre></td></tr></table></figure>

<hr>
<p><a id="D"><font color="black" size="5"><strong>D. Flag - From CodeForces 16A</strong></font></a></p>
<p>原题地址：<a href="https://codeforces.com/problemset/problem/16/A">https://codeforces.com/problemset/problem/16/A</a></p>
<p><img src="http://ys-c.ysepan.com/544024545/713499361/kibtqyq35683T64KHMXJd2/20230309D1.png" alt="D题题面"><br><img src="http://ys-c.ysepan.com/544024546/713499362/l49562V56GIQWIkibtqyd7/20230309D2.png" alt="D题样例"></p>
<p>签到题，没什么好说的。</p>
<p>本题AC代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    char x[105][105];</span><br><span class="line">    int n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x[i];</span><br><span class="line">        if(i!=1&amp;&amp;x[i][0]==x[i-1][0])&#123;</span><br><span class="line">            cout&lt;&lt;&quot;NO&quot;;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=1;j&lt;m;j++)&#123;</span><br><span class="line">            if(x[i][j]!=x[i][j-1])&#123;</span><br><span class="line">                cout&lt;&lt;&quot;NO&quot;;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;YES&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/**************************************************************</span><br><span class="line">    Problem: 3663</span><br><span class="line">    User: 123 [URright]</span><br><span class="line">    Language: C++</span><br><span class="line">    Result: 正确</span><br><span class="line">    Time:13 ms</span><br><span class="line">    Memory:2176 kb</span><br><span class="line">****************************************************************/</span><br></pre></td></tr></table></figure>

<hr>
<p><a id="E"><font color="black" size="5"><strong>E. Smart Boy - From CodeForces 38F</strong></font></a></p>
<p>原题地址：<a href="https://codeforces.com/problemset/problem/38/F">https://codeforces.com/problemset/problem/38/F</a></p>
<p><img src="http://ys-c.ysepan.com/544024518/713499374/q76273W3467N2kfeupu16/20230309E1.png" alt="E题题面"><br><img src="http://ys-c.ysepan.com/544024518/713499375/q76273W3467N3kfeupu23/20230309E2.png" alt="E题样例"></p>
<p>被中间的得分公式吓到了，所以没仔细看题目。<br><del>（估计看了也写不出来罢）</del><br>题目大意：两个玩家为了玩一个叫聪明男孩的游戏创建了一个含有n个单词的词典，然后他们轮流从空字符串开始构造字符串，必须选择词典中某个单词用到的字母且必须只能加在字符串的开头或结尾，构造完后若该字符串是词典中某个单词的子串则获得分数，否则该玩家失败。分数公式中value(字母)返回该字母为字母表中第几个，nums(s)为词典中中以s为子串的字符串数量。每个人在操作时采取最优策略让自己赢，且在保证自己赢的情况下使得自己得分最高，在保证自己赢且得分最高的情况下使得对方得分尽可能少，问最后谁会赢以及两个人的得分各是多少。</p>
<p>在网上找了一下题解，似乎只要预处理每个子串的和然后记忆化搜索就能解出来了。具体代码思路还得研究研究。</p>
<p>本题AC代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">#include &lt;cstdio&gt;  </span><br><span class="line">#include &lt;cstring&gt;  </span><br><span class="line">#include &lt;string&gt;  </span><br><span class="line">#include &lt;algorithm&gt;  </span><br><span class="line">#include &lt;map&gt;  </span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;stack&gt;  </span><br><span class="line">#include &lt;queue&gt;  </span><br><span class="line">#include &lt;vector&gt;  </span><br><span class="line">#include &lt;bitset&gt;  </span><br><span class="line">#include &lt;functional&gt;  </span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define LL long long</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line"> </span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">	int sg, sum1, sum2;</span><br><span class="line">	bool operator &lt; (const node &amp;x)const</span><br><span class="line">	&#123;</span><br><span class="line">		if (sg != x.sg) return sg &lt; x.sg;</span><br><span class="line">		if (sum1 != x.sum1) return sum1 &lt; x.sum1;</span><br><span class="line">		return sum2 &gt; x.sum2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">set&lt;string&gt;S;</span><br><span class="line">map&lt;string, node&gt;mp;</span><br><span class="line">map&lt;string, int&gt;num;</span><br><span class="line"> </span><br><span class="line">int get(string s)</span><br><span class="line">&#123;</span><br><span class="line">	int ans = 0, mx = 0, len = s.length();</span><br><span class="line">	for (int i = 0; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans += s[i] - &#x27;a&#x27; + 1;</span><br><span class="line">		mx = max(mx, s[i] - &#x27;a&#x27; + 1);</span><br><span class="line">	&#125;</span><br><span class="line">	return ans * mx + num[s];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">node dfs(string s)</span><br><span class="line">&#123;</span><br><span class="line">	if (mp.find(s) != mp.end()) return mp[s];</span><br><span class="line">	node ans = &#123; 0, 0, 0 &#125;;</span><br><span class="line">	for (int i = 0; i &lt; 26; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		string ss = s + char(&#x27;a&#x27; + i);</span><br><span class="line">		if (S.find(ss) != S.end())</span><br><span class="line">		&#123;</span><br><span class="line">			node tmp = dfs(ss);</span><br><span class="line">			swap(tmp.sum1, tmp.sum2);</span><br><span class="line">			tmp.sg ^= 1;</span><br><span class="line">			tmp.sum1 += get(ss);</span><br><span class="line">			if (ans &lt; tmp) ans = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		ss = char(&#x27;a&#x27; + i) + s;</span><br><span class="line">		if (S.find(ss) != S.end())</span><br><span class="line">		&#123;</span><br><span class="line">			node tmp = dfs(ss);</span><br><span class="line">			swap(tmp.sum1, tmp.sum2);</span><br><span class="line">			tmp.sg ^= 1;</span><br><span class="line">			tmp.sum1 += get(ss);</span><br><span class="line">			if (ans &lt; tmp) ans = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return mp[s] = ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, len;</span><br><span class="line">	string s, ss;</span><br><span class="line">	while (~scanf(&quot;%d&quot;, &amp;n))</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i = 1; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; s;</span><br><span class="line">			set&lt;string&gt;tmp;</span><br><span class="line">			len = s.length();</span><br><span class="line">			for (int j = 0; j &lt; len; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				for (int k = j; k &lt; len; k++)</span><br><span class="line">				&#123;</span><br><span class="line">					ss = s.substr(j, k - j + 1);</span><br><span class="line">					S.insert(ss);</span><br><span class="line">					if (tmp.find(ss) == tmp.end())</span><br><span class="line">					&#123;</span><br><span class="line">						tmp.insert(ss);</span><br><span class="line">						num[ss]++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		node ans = dfs(&quot;&quot;);</span><br><span class="line">		if (ans.sg) printf(&quot;First\n&quot;);</span><br><span class="line">		else printf(&quot;Second\n&quot;);</span><br><span class="line">		printf(&quot;%d %d\n&quot;, ans.sum1, ans.sum2);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码原文链接：<a href="https://blog.csdn.net/a664607530/article/details/79844768">https://blog.csdn.net/a664607530/article/details/79844768</a></p>
<hr>
<p><a id="F"><font color="black" size="5"><strong>F. Airport - From CodeForces 218B</strong></font></a></p>
<p>原题地址：<a href="https://codeforces.com/problemset/problem/218/B">https://codeforces.com/problemset/problem/218/B</a></p>
<p><img src="http://ys-k.ysepan.com/544024542/713499999/h665436633KNL3kibtqybc/20230309F1.png" alt="F题题面"><br><img src="http://ys-k.ysepan.com/544024542/713500000/h665436633KNL4kibtqy2d/20230309F2.png" alt="F题样例"></p>
<p>又是一道拿下手刹的题，感谢zjk的快速翻译，三人一起讨论了之后马上有思路了，代码一气呵成。<br>题意是输入乘客数n和飞机数m，再输入m个数代表飞机上的位置数和价格，价格会随着位置数的减少同时降低，例如有2个位置时是2块钱，有1个位置时就是1块，要求输出搭乘这几架飞机能赚到的最大值和最小值。</p>
<p>思路也很清晰，输入桶排后取座位数的最大值和最小值，然后依次向上&#x2F;向下遍历，循环乘客数量次后跳出循环输出结果。</p>
<p>本题AC代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int seatmax[1005]=&#123;0&#125;,seatmin[1005]=&#123;0&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n1,n2,plane,s,maxn=0,minn=1005;</span><br><span class="line">    cin&gt;&gt;n1&gt;&gt;plane;</span><br><span class="line">    n2=n1;</span><br><span class="line">    for(int i=1;i&lt;=plane;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        seatmax[s]++;</span><br><span class="line">        seatmin[s]++;</span><br><span class="line">        if(maxn&lt;s)maxn=s;</span><br><span class="line">        if(minn&gt;s)minn=s;</span><br><span class="line">    &#125;</span><br><span class="line">    int resulta=0,resultb=0;</span><br><span class="line">    while(n1&gt;0)&#123;</span><br><span class="line">        while(seatmax[maxn]==0)&#123;</span><br><span class="line">            maxn--;</span><br><span class="line">        &#125;</span><br><span class="line">        resulta+=maxn;</span><br><span class="line">        seatmax[maxn]--;</span><br><span class="line">        seatmax[maxn-1]++;</span><br><span class="line">        n1--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;resulta&lt;&lt;&quot; &quot;;</span><br><span class="line">    while(n2&gt;0)&#123;</span><br><span class="line">        while(seatmin[minn]==0)&#123;</span><br><span class="line">            minn++;</span><br><span class="line">        &#125;</span><br><span class="line">        resultb+=minn;</span><br><span class="line">        seatmin[minn]--;</span><br><span class="line">        seatmin[minn-1]++;</span><br><span class="line">        if(minn!=1)minn=minn-1;</span><br><span class="line">        n2--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;resultb;</span><br><span class="line">&#125;</span><br><span class="line">/**************************************************************</span><br><span class="line">    Problem: 3504</span><br><span class="line">    User: 123 [URright]</span><br><span class="line">    Language: C++</span><br><span class="line">    Result: 正确</span><br><span class="line">    Time:13 ms</span><br><span class="line">    Memory:2184 kb</span><br><span class="line">****************************************************************/</span><br></pre></td></tr></table></figure>

<hr>
<p><a id="G"><font color="black" size="5"><strong>G. Three Arrays - From CodeForces 392D</strong></font></a></p>
<p>原题地址：<a href="https://codeforces.com/problemset/problem/392/D">https://codeforces.com/problemset/problem/392/D</a></p>
<p><img src="http://ys-f.ysepan.com/544024516/713503163/n4956354MF3Q73kfeupu5e/20230309G1.png" alt="G题题面"><br><img src="http://ys-f.ysepan.com/544024516/713503164/n4956354MF3Q74kfeupu68/20230309G2.png" alt="G题样例"></p>
<p>找了半天，最后在别人的cf的博客里找到了题解。<br>题解链接：<a href="https://codeforces.com/blog/entry/83942">https://codeforces.com/blog/entry/83942</a></p>
<p>假设某个数k在b中只出现一次，在c中只出现了一次，并且b[i]&#x3D;c[j]&#x3D;k。然后我们表示pos[i]&#x3D;j。现在，如果k在c中有多次出现，我们将取最小的j。如果它在b中有多次发生，我们将第一个pos[i]设置为j，其他设置为0。现在问题的答案是mini（（i−1）+maxj&gt;ipos[j]）。括号中的表达式对应于我们从b中取i个元素时的情况。然后我们查找所有其他元素（j&gt;i），并选择包含所有这些元素的c的最短前缀。这解释了为什么我们将c中k的第一次出现写为pos。我们用零填充其他值，因为如果我们已经在b中出现了第一次，我们就不需要它们了。<br>现在回到有a的情况。如果a中有一些数字，会发生什么变化？那么，在这种情况下，我们可以为b中出现的所有数字设置pos[i]&#x3D;0（不仅仅是除第一个之外的所有数字）。这意味着，如果我们从0到n迭代a的前缀，那么我们将不得不将一些pos更改为零。但我更喜欢将零更改为某些值，因此我们将从n迭代到0。<br>假设我们决定不在a中使用长度为i的前缀，而是使用长度为i-1的前缀。如果i之前出现了一些a[i]，那么pos中没有任何变化。但是如果i之前没有a[i]，我们必须更新一些pos并重新计算mini（（i−1）+maxj&gt;ipos[j]）。我相信有不同的结构可以做到这一点，我将描述我所使用的。<br>在表达式中，后缀上有最大值。它们可以存储为对（p，m），这意味着后缀上的p最大值至少为m（显然，后缀上的最大值是一个非递增函数）。现在，为了计算答案，我们不必遍历所有i。我们只需要考虑这样的指数p，即集合中存在某对（p−1，？）。这意味着我们必须为每对相邻的对检查一个选项。记住，我们只需要向这个集合添加对。而且很容易——添加一对，并在它之前删除足够多的对（而它们的m小于新的m）。对于每个添加或删除，我们都有O（1）个选项的添加或删除。当前答案可以存储在多集合中，因为我们只需要最小值。如果我们看到a的前缀i，那么我们必须用i+（multiset中的最小值）更新答案。</p>
<p>本题AC代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; a(n), b(n), c(n);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; c[i];</span><br><span class="line"></span><br><span class="line">    for (auto k : c) &#123;</span><br><span class="line">        b.push_back(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map&lt;int, int&gt; whereb;</span><br><span class="line">    map&lt;int, int&gt; wherec;</span><br><span class="line">    for (int i = (int)b.size() - 1; i &gt;= 0; --i)</span><br><span class="line">        whereb[b[i]] = i;</span><br><span class="line">    for (int i = (int)c.size() - 1; i &gt;= 0; --i)</span><br><span class="line">        wherec[c[i]] = i;</span><br><span class="line"></span><br><span class="line">    vector&lt;bool&gt; first_in_a(a.size(), false);</span><br><span class="line">    vector&lt;bool&gt; first_in_b(b.size(), false);</span><br><span class="line">    set&lt;int&gt; ina, inb;</span><br><span class="line">    for (int i = 0; i &lt; a.size(); ++i) &#123;</span><br><span class="line">        if (!ina.count(a[i])) &#123;</span><br><span class="line">            ina.insert(a[i]);</span><br><span class="line">            first_in_a[i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; b.size(); ++i) &#123;</span><br><span class="line">        if (!inb.count(b[i])) &#123;</span><br><span class="line">            inb.insert(b[i]);</span><br><span class="line">            first_in_b[i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set&lt;pair&lt;int, int&gt;&gt; maxs;</span><br><span class="line">    multiset&lt;int&gt; res;</span><br><span class="line"></span><br><span class="line">    maxs.emplace(1e9, 0);</span><br><span class="line">    maxs.emplace(-1, 1e9 + 5);</span><br><span class="line">    res.insert(maxs.begin()-&gt;first + next(maxs.begin())-&gt;second + 1);</span><br><span class="line"></span><br><span class="line">    auto del = [&amp;](pair&lt;int, int&gt; p) &#123;</span><br><span class="line">        auto it = maxs.find(p);</span><br><span class="line">        assert(it != maxs.end());</span><br><span class="line">        auto inext = next(it);</span><br><span class="line">        auto iprev = prev(it);</span><br><span class="line"></span><br><span class="line">        res.erase(res.find(iprev-&gt;first + it-&gt;second + 1));</span><br><span class="line">        res.erase(res.find(it-&gt;first + inext-&gt;second + 1));</span><br><span class="line">        maxs.erase(it);</span><br><span class="line">        res.insert(iprev-&gt;first + inext-&gt;second + 1);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    auto add = [&amp;](pair&lt;int, int&gt; p) &#123;</span><br><span class="line">        auto it = maxs.lower_bound(make_pair(p.first, -5));</span><br><span class="line">        if (it-&gt;second &gt;= p.second) return;</span><br><span class="line">        if (it-&gt;first == p.first) &#123;</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">        while (prev(it)-&gt;second &lt;= p.second)</span><br><span class="line">            del(*prev(it));</span><br><span class="line"></span><br><span class="line">        maxs.insert(p);</span><br><span class="line">        it = maxs.find(p);</span><br><span class="line">        auto inext = next(it);</span><br><span class="line">        auto iprev = prev(it);</span><br><span class="line"></span><br><span class="line">        res.insert(iprev-&gt;first + it-&gt;second + 1);</span><br><span class="line">        res.insert(it-&gt;first + inext-&gt;second + 1);</span><br><span class="line">        res.erase(res.find(iprev-&gt;first + inext-&gt;second + 1));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; b.size(); ++i) &#123;</span><br><span class="line">        if (first_in_b[i] &amp;&amp; !ina.count(b[i])) &#123;</span><br><span class="line">            int inc = 1e9;</span><br><span class="line">            if (wherec.count(b[i]))</span><br><span class="line">                inc = wherec[b[i]] + 1;</span><br><span class="line">            add(&#123;i, inc&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans = n + *res.begin();</span><br><span class="line"></span><br><span class="line">    for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        if (first_in_a[i]) &#123;</span><br><span class="line">            if (!inb.count(a[i])) break;</span><br><span class="line">            int inc = 1e9;</span><br><span class="line">            if (wherec.count(a[i]))</span><br><span class="line">                inc = wherec[a[i]] + 1;</span><br><span class="line">            add(&#123;whereb[a[i]], inc&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = min(ans, i + *res.begin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><a id="H"><font color="black" size="5"><strong>H. Sockets - From CodeForces 257A</strong></font></a></p>
<p>原题地址：<a href="https://codeforces.com/problemset/problem/257/A">https://codeforces.com/problemset/problem/257/A</a></p>
<p><img src="http://ys-f.ysepan.com/544024540/713503186/r5546623NK3M6Kkibtqy84/20230309H1.png" alt="H题题面"><br><img src="http://ys-f.ysepan.com/544024540/713503187/r5546623NK3M6Lkibtqyac/20230309H2.png" alt="H题样例"></p>
<p>纯水题，更离谱的是这道题最后有人做出来之后才陆陆续续做出来，大家都没发现。<br>一开始看这题的也是我，吃了没文化的大亏呜呜呜。结果三个人一起看才看懂。<br>有n条插板，m个设备和k个固定插孔，n条插板上各有an个插孔，问最少需要几个插板能让所有设备通电，不能则输出-1。<br>很简单的一题，先让每个插孔数-1，然后排序，再从大到小一个个加，加到插孔数超过设备数后停下来。最后输出插板数。</p>
<p>本题AC代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,k,x0,i;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    int x[55];</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x0;</span><br><span class="line">        x[i]=x0-1;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(x,x+n);</span><br><span class="line">    if(m&lt;=k)&#123;</span><br><span class="line">        cout&lt;&lt;0;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int re=0;</span><br><span class="line">    for(i=n-1;i&gt;=0;i--)&#123;</span><br><span class="line">        k+=x[i];</span><br><span class="line">        re++;</span><br><span class="line">        if(k&gt;=m)&#123;</span><br><span class="line">            cout&lt;&lt;re;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i&lt;0)cout&lt;&lt;-1;</span><br><span class="line">&#125;</span><br><span class="line">/**************************************************************</span><br><span class="line">    Problem: 3383</span><br><span class="line">    User: 123 [URright]</span><br><span class="line">    Language: C++</span><br><span class="line">    Result: 正确</span><br><span class="line">    Time:13 ms</span><br><span class="line">    Memory:2176 kb</span><br><span class="line">****************************************************************/</span><br></pre></td></tr></table></figure>
<p>属于是很紧张了，最后15分钟发现这题，然后用了5分钟一气呵成。哈人。</p>
<hr>
<p><a id="I"><font color="black" size="5"><strong>I. Apple Tree - From CodeForces 349D</strong></font></a></p>
<p>原题地址：<a href="https://codeforces.com/contest/349/problem/D">https://codeforces.com/contest/349/problem/D</a></p>
<p><img src="http://ys-f.ysepan.com/544024540/713503198/r5546623O54MI4kibtqy32/20230309I1.png" alt="I题题面"><br><img src="http://ys-f.ysepan.com/544024540/713503199/r5546623O54MI5kibtqyba/20230309I2.png" alt="I题样例"></p>
<p>比赛的时候稍稍看了眼这道题，但还是败在了英语上，所以没做下去。<br>题意其实也很简单，给一颗树，每个叶子结点上都有苹果，要求相同高度的每个结点上所拥有的苹果数相等，求最少应该摘掉几个苹果才能满足这个条件。<br>我们不妨做个假设：一棵树根节点有3个儿子，每个儿子分别又有2，3，4个儿子（假设他们全是叶子结点且上面都有苹果），那么相当于要分别分2，3，4个苹果给这些孙子。又因为每个分支需要分到的苹果数量相等，所以可以求出他们的最小公倍数lcm，例如每个节点12个，这样就能满足每个分支苹果数量相等了；若取最大值，就是先求出这个分支的苹果总数sum[i]，再减去sum[i]%lcm使之成为lcm的整数倍，就能得到最大值了。运用dfs向根节点递归即可得到答案。</p>
<p>本题AC代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n,a[200005];//a为每个节点本身的苹果数量 </span><br><span class="line">ll sum[200005],cnt[200005];//sum为每个节点下的苹果总数，cnt为每个节点的分支数 </span><br><span class="line">vector&lt;int&gt;g[200005];//连接的节点有哪些，第一个是父节点，后面的都是子节点 </span><br><span class="line">ll gcd(ll a,ll b)</span><br><span class="line">&#123;</span><br><span class="line">    return b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line">ll lcm(ll a,ll b)</span><br><span class="line">&#123;</span><br><span class="line">    return a/gcd(a,b)*b;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int u,int fa)//节点和父节点 </span><br><span class="line">&#123;</span><br><span class="line">    int next=0;</span><br><span class="line">    for(int i=0;i&lt;(int)g[u].size();i++)&#123;</span><br><span class="line">        int v=g[u][i];</span><br><span class="line">        if(v==fa) continue;//遇到父节点跳过</span><br><span class="line">        dfs(v,u);</span><br><span class="line">        if(!next)&#123;</span><br><span class="line">            sum[u]=sum[v];</span><br><span class="line">            cnt[u]=cnt[v];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            if(cnt[u]&lt;5e13) cnt[u]=lcm(cnt[u],cnt[v]);</span><br><span class="line">            sum[u]=min(sum[u],sum[v])/cnt[u]*cnt[u];</span><br><span class="line">        &#125;</span><br><span class="line">        next++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!next)&#123;//叶子结点</span><br><span class="line">        sum[u]=a[u];cnt[u]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;//非叶子结点 </span><br><span class="line">        sum[u]*=next;</span><br><span class="line">        if(cnt[u]&lt;5e13) cnt[u]*=next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    ll ans=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">        ans+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int x,y;</span><br><span class="line">    for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">        g[x].push_back(y);</span><br><span class="line">        g[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    dfs(1,0);</span><br><span class="line">    cout&lt;&lt;ans-sum[1];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><a id="J"><font color="black" size="5"><strong>J. Game with Strings - From CodeForces 354B</strong></font></a></p>
<p>原题地址：<a href="https://codeforces.com/contest/354/problem/B">https://codeforces.com/contest/354/problem/B</a></p>
<p><img src="http://ys-j.ysepan.com/544024539/713503679/lgfsmzu554662498HMMI64/20230309J1.png" alt="J题题面"><br><img src="http://ys-j.ysepan.com/544024539/713503680/lgfsmzu554662498HMMJ95/20230309J2.png" alt="J题样例"></p>
<p>网上找不到题解，但是有源代码，于是试着理解了一下。<br>大致意思是两个人从空字符串开始玩拼字符游戏，拼上去的字母需满足：加上该字母所得的新字符串必须为某个矩阵中从左上到右下拼成的所有可能的字符串的其中一种。拼到最后如果字母a的数量比b多则输出FIRST，比a少输出SECOND，相等输出DRAW。两个人都要尽可能赢所以需要走最佳状况。<br>首先建个二维的dp数组。第一维表示走到第几步。可以画一个正方形，以左上角斜着划线，第i步走的点只能是第i条线上的点；第二维表示第i步可以到达的点的状态。接着另开一个a数组来表示第i条线上每个字母的状态。dp所代表的值就为a与b的差值，并以此进行记忆化操作。</p>
<p>本题AC代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define LL __int64</span><br><span class="line">#define INF 1e9</span><br><span class="line">int dp[42][1&lt;&lt;20],a[42][42];</span><br><span class="line">char s[22][22];</span><br><span class="line">int n;</span><br><span class="line">int dfs(int step,int sta)</span><br><span class="line">&#123;</span><br><span class="line">    int i,num=0;</span><br><span class="line">    if(dp[step][sta]!=INF)</span><br><span class="line">    return dp[step][sta];</span><br><span class="line">    for(i = 0; i &lt; n ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(sta&amp;(1&lt;&lt;i))</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[step-i][i]==&#x27;a&#x27;) num++;</span><br><span class="line">            else if(s[step-i][i]==&#x27;b&#x27;) num--;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(step==2*n-2)</span><br><span class="line">    return dp[step][sta] = num;</span><br><span class="line">    if(step%2!=0)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[step][sta] = -INF;</span><br><span class="line">        for(i = 0 ; i &lt; 26 ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int next = a[step+1][i]&amp;(sta|(sta&lt;&lt;1));</span><br><span class="line">            if(next==0)</span><br><span class="line">            continue;</span><br><span class="line">            dp[step][sta] = max(dp[step][sta],dfs(step+1,next)+num);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[step][sta];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for(i = 0 ; i &lt; 26 ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int next = a[step+1][i]&amp;(sta|(sta&lt;&lt;1));</span><br><span class="line">            if(next==0)</span><br><span class="line">            continue;</span><br><span class="line">            dp[step][sta] = min(dp[step][sta],dfs(step+1,next)+num);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[step][sta];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(i = 0 ; i &lt; n ; i++)</span><br><span class="line">    cin&gt;&gt;s[i];</span><br><span class="line">    for(i = 0 ; i &lt; 2*n-1 ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j = 0 ; j &lt; n ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i-j&lt;0||i-j&gt;=n) continue;</span><br><span class="line">            a[i][s[i-j][j]-&#x27;a&#x27;] |= (1&lt;&lt;j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i = 0 ; i &lt; 2*n ; i++)</span><br><span class="line">        for(j = 0 ; j &lt; (1&lt;&lt;n) ; j++)</span><br><span class="line">        dp[i][j] = INF;</span><br><span class="line">    int ans = dfs(0,1);</span><br><span class="line">    if(ans&gt;0)</span><br><span class="line">    puts(&quot;FIRST&quot;);</span><br><span class="line">    else if(ans&lt;0)</span><br><span class="line">    puts(&quot;SECOND&quot;);</span><br><span class="line">    else</span><br><span class="line">    puts(&quot;DRAW&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><font size="6"><strong>写在最后</strong></font></p>
<p>没想到大二第二个学期这么快就开始了。这也是这个学期的第一次ACM校赛，拿到这个成绩也是意料之外情理之中。寒假由于父亲的身体原因，本想着认真学一个寒假的算法，结果因为住院陪同而没能完整学下去。不过好在后来报了Namomo Winter Camp，或多或少学了些东西进去。但开学后又把算法忘得一干二净，等期末考完后再次拿起算法书发现已经生分了许多。</p>
<p>但只要想学习，总是有机会学的，所以归根结底还是得从自己身上找原因。把这次比赛当做一个教训，在接下来的日子里努力学算法，刷题打cf，不求做得最好，只求尽力而为。正如dls在开营仪式中所说的，“仰望星空，脚踏实地。”接下来一步一个脚印，心无旁骛，抬头看路，足矣。</p>
<p>接下来的蓝桥杯省赛和天梯赛继续加油啦。<br>如果还有第二次ACM选拔赛，希望能拿下。当然尽力而为才是最大的胜利。</p>
<p>2023&#x2F;03&#x2F;12 00:51 于201寝室</p>
]]></content>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
</search>
